/* 
* Copyright (C) 2002-2007 XimpleWare, info@ximpleware.com
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/
// added set
using System;
using UTF8Char = com.ximpleware.parser.UTF8Char;
using com.ximpleware.parser;
namespace com.ximpleware
{
    /// <summary> 
    /// 
    /// </summary>
    /// <summary> VTD navigator class implementation</summary>
    public class VTDNav
    {
        /// <summary> Return the attribute count of the element at the cursor position.
        /// when ns is false, ns tokens are considered attributes;
        /// otherwise, ns tokens are not considered attributes
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getAttrCount()
        {
            if (context[0] == -1)
                return 0;
            int count = 0;
            int index = getCurrentIndex() + 1;
            while (index < vtdSize)
            {
                int type = getTokenType(index);
                if (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_VAL || type == TOKEN_ATTR_NS)
                {
                    if (type == TOKEN_ATTR_NAME || (!ns && (type == TOKEN_ATTR_NS)))
                    {
                        count++;
                    }
                }
                else
                    break;
                index++;
            }
            return count;
        }

        static public int swap_bytes(int i)
        {
            return (((i & 0xff) << 24) |
                ((i & 0xff00) << 8) |
                ((i & 0xff0000) >> 8) |
                ((i & -0x01000000) >> 24) & 0xff);
        }

      

        /// <summary> This method decodes the underlying byte array into corresponding UCS2 char representation .
        /// It doesn't resolves built-in entity and character references.
        /// Length will never be zero
        /// Creation date: (11/21/03 6:26:17 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception is thrown if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD can be generated by another
        /// machine, e.g. from a load-balancer.
        /// </exception>
        private long getChar(int offset)
        {
            long temp = 0;

            switch (encoding)
            {

                case FORMAT_ASCII:  // ascii is compatible with UTF-8, the offset value is bytes
                    temp = XMLDoc.byteAt(offset);
                    if (temp == '\r')
                    {
                        if (XMLDoc.byteAt(offset + 1) == '\n')
                        {
                            return '\n' | (2L << 32);
                        }
                        else
                        {
                            return '\n' | (1L << 32);
                        }
                    }
                    return temp | (1L << 32);

                case FORMAT_ISO_8859_1:
                    temp = XMLDoc.byteAt(offset);
                    if (temp == '\r')
                    {
                        if (XMLDoc.byteAt(offset + 1) == '\n')
                        {
                            return '\n' | (2L << 32);
                        }
                        else
                        {
                            return '\n' | (1L << 32);
                        }
                    }
                    return temp | (1L << 32);

                case FORMAT_UTF8:
                    temp = XMLDoc.byteAt(offset);
                    if (temp >= 0)
                    {
                        if (temp == '\r')
                        {
                            if (XMLDoc.byteAt(offset + 1) == '\n')
                            {
                                return '\n' | (2L << 32);
                            }
                            else
                            {
                                return '\n' | (1L << 32);
                            }
                        }
                        //currentOffset++;
                        return temp | (1L << 32);
                    }
                    return handle_utf8(temp, offset);

                case FORMAT_UTF_16BE:
                    // implement UTF-16BE to UCS4 conversion

                    return handle_utf16be(offset);


                case FORMAT_UTF_16LE:

                    return handle_utf16le(offset);
                //System.out.println("UTF 16 LE unimplemented for now");
                //goto default;


                default:
                    
                    throw new NavException("Unknown Encoding");
            }



            /* the exact same copy of getChar except it operates on currentOffset2
            * this is needed to compare VTD tokens directly
            */

        }

        /// <summary> This method decodes the underlying byte array into corresponding UCS2 char representation .
        /// Also it resolves built-in entity and character references.
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception is thrown if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        private long getCharResolved(int offset)
        {
            int ch = 0;
            int val = 0;
            long inc = 2;
            long l = getChar(offset);

            ch = (int)l;

            if (ch != '&')
                return l;

            // let us handle references here
            offset++;
            ch = getCharUnit(offset);
            offset++;
            switch (ch)
            {

                case '#':

                    ch = getCharUnit(offset);

                    if (ch == 'x')
                    {
                        while (true)
                        {
                            offset++;
                            inc++;
                            ch = getCharUnit(offset);

                            if (ch >= '0' && ch <= '9')
                            {
                                val = (val << 4) + (ch - '0');
                            }
                            else if (ch >= 'a' && ch <= 'f')
                            {
                                val = (val << 4) + (ch - 'a' + 10);
                            }
                            else if (ch >= 'A' && ch <= 'F')
                            {
                                val = (val << 4) + (ch - 'A' + 10);
                            }
                            else if (ch == ';')
                            {
                                inc++;
                                break;
                            }
                            else
                                throw new NavException("Illegal char in a char reference");
                        }
                    }
                    else
                    {
                        while (true)
                        {
                            ch = getCharUnit(offset);
                            offset++;
                            inc++;
                            if (ch >= '0' && ch <= '9')
                            {
                                val = val * 10 + (ch - '0');
                            }
                            else if (ch == ';')
                            {
                                break;
                            }
                            else
                                throw new NavException("Illegal char in char reference");
                        }
                    }
                    break;


                case 'a':
                    ch = getCharUnit(offset);
                    if (ch == 'm')
                    {
                        if (getCharUnit(offset + 1) == 'p' && getCharUnit(offset + 2) == ';')
                        {
                            inc = 5;
                            val = '&';
                        }
                        else
                            throw new NavException("illegal builtin reference");
                    }
                    else if (ch == 'p')
                    {
                        if (getCharUnit(offset + 1) == 'o' && getCharUnit(offset + 2) == 's' && getCharUnit(offset + 3) == ';')
                        {
                            inc = 6;
                            val = '\'';
                        }
                        else
                            throw new NavException("illegal builtin reference");
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;


                case 'q':

                    if (getCharUnit(offset) == 'u'
                        && getCharUnit(offset + 1) == 'o'
                        && getCharUnit(offset + 2) == 't'
                        && getCharUnit(offset + 3) == ';')
                    {
                        inc = 6;
                        val = '\"';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;

                case 'l':
                    if (getCharUnit(offset) == 't'
                        && getCharUnit(offset + 1) == ';')
                    {
                        inc = 4;
                        val = '<';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;

                case 'g':
                    if (getCharUnit(offset) == 't' && getCharUnit(offset + 1) == ';')
                    {
                        inc = 4;
                        val = '>';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;


                default:
                    throw new NavException("Invalid entity char");

            }

            //currentOffset++;
            return val | (inc << 32);
        }


        public int getCurrentDepth()
        {
            return context[0];
        }
        /// <summary> Get the index value of the current element.
        /// Creation date: (11/16/03 6:40:25 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getCurrentIndex()
        {
            if (atTerminal)
                return LN;
            switch (context[0])
            {

                case -1: return 0;

                case 0: return rootIndex;

                default: return context[context[0]];

            }
            //return (context[0] == 0) ? rootIndex : context[context[0]];

        }
        protected internal int getCurrentIndex2()
        {
            switch (context[0])
            {

                case -1: return 0;

                case 0: return rootIndex;

                default: return context[context[0]];

            }
        }
        /// <summary> Get the starting offset and length of an element
        /// encoded in a long, upper 32 bit is length; lower 32 bit is offset
        /// Unit is in byte.
        /// Creation date: (3/15/04 1:47:55 PM)
        /// </summary>
        public long getElementFragment()
        {
            // a little scanning is needed
            // has next sibling case
            // if not
            int temp, so2, d, i;
            int depth = getCurrentDepth();
            //		 document length and offset returned if depth == -1
            if (depth == -1)
            {
                int ii = vtdBuffer.lower32At(0);
                if (ii == 0)
                    return ((long)docLen) << 32 | docOffset;
                else
                    return ((long)(docLen - 32)) | 32;
            }
            int so = getTokenOffset(getCurrentIndex2()) - 1;
            int length = 0;


            // for an element with next sibling
            if (toElement(NEXT_SIBLING))
            {

                temp = getCurrentIndex();
                // rewind 
                while (getTokenDepth(temp) < depth)
                {
                    temp--;
                }
                //temp++;
                so2 = getTokenOffset(temp) - 1;
                // look for the first '>'
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                length = so2 - so + 1;
                toElement(PREV_SIBLING);
                if (encoding <= 2)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }

            // for root element
            if (depth == 0)
            {
                temp = vtdBuffer.size() - 1;
                bool b = false;
                so2 = 0;
                while (getTokenDepth(temp) == -1)
                {
                    temp--; // backward scan
                    b = true;
                }
                if (b == false)
                    so2 = (encoding < 3) ? (docOffset + docLen - 1) : ((docOffset + docLen) << 1) - 1;
                else
                    so2 = getTokenOffset(temp + 1);
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                length = so2 - so + 1;
                if (encoding <= 2)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }
            // for a non-root element with no next sibling
            temp = getCurrentIndex() + 1;
            int size = vtdBuffer.size();
            // temp is not the last entry in VTD buffer
            if (temp < size - 1)
            {
                while (temp < size && getTokenDepth(temp) >= depth)
                {
                    temp++;
                }
                if (temp != size)
                {
                    d = depth - getTokenDepth(temp) + ((getTokenType(temp) == TOKEN_STARTING_TAG) ? 1 : 0);
                    so2 = getTokenOffset(temp) - 1;
                    i = 0;
                    // scan backward
                    while (i < d)
                    {
                        if (getCharUnit(so2) == '>')
                            i++;
                        so2--;
                    }
                    length = so2 - so + 2;
                    if (encoding <= 2)
                        return ((long)length) << 32 | so;
                    else
                        return ((long)length) << 33 | (so << 1);
                }
                /*
                int so2 = getTokenOffset(temp - 1) - 1;
                int d = depth - getTokenDepth(temp - 1);
                int i = 0;
                while (i < d) {
                if (getCharUnit(so2) == '>') {
                i++;
                }
                so2--;
                }
                length = so2 - so + 2;
                if (encoding < 3)
                return ((long) length) << 32 | so;
                else
                return ((long) length) << 33 | (so << 1);*/
            }
            // temp is the last entry
            // scan forward search for /> or </cc>
            so2 = (encoding <= 2) ? (docOffset + docLen - 1) : ((docOffset + docLen) << 1) - 1;
            d = depth + 1;
            i = 0;
            while (i < d)
            {
                if (getCharUnit(so2) == '>')
                {
                    i++;
                }
                so2--;
            }

            length = so2 - so + 2;

            if (encoding <= 2)
                return ((long)length) << 32 | so;
            else
                return ((long)length) << 33 | (so << 1);


        }
        /// <summary> Get the encoding of the XML document.
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getEncoding()
        {
            return encoding;
        }
        /// <summary> Get the maximum nesting depth of the XML document (>0).
        /// max depth is nestingLevel -1
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getNestingLevel()
        {
            return nestingLevel;
        }
        /// <summary> Get root index value , which is the index val of document element</summary>
        /// <returns> int
        /// </returns>
        public int getRootIndex()
        {
            return rootIndex;
        }
        /// <summary> This method returns of the token index of the type character data or CDATA.
        /// Notice that it is intended to support data orient XML (not mixed-content XML).
        /// return the index of the text token, or -1 if none exists.
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getText()
        {
            if (context[0] == -1)
                return -1;
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            int depth = getCurrentDepth();
            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;

            while (true)
            {
                if (type == TOKEN_CHARACTER_DATA || type == TOKEN_CDATA_VAL)
                {
                    if (depth == getTokenDepth(index))
                        return index;
                    else
                        return -1;
                }
                else if (type == TOKEN_ATTR_NS || type == TOKEN_ATTR_NAME)
                {
                    index += 2; // assuming a single token for attr val
                }
                else if (type == TOKEN_PI_NAME || type == TOKEN_PI_VAL || type == TOKEN_COMMENT)
                {
                    if (depth == getTokenDepth(index))
                    {
                        index += 1;
                    }
                    else
                        return -1;
                }
                else
                    return -1;
                if (index >= vtdSize)
                    break;
                type = getTokenType(index);
            }
            return -1;
        }
        /// <summary> Get total number of VTD tokens for the current XML document.</summary>
        /// <returns> int
        /// </returns>
        public int getTokenCount()
        {
            return vtdSize;
        }
        /// <summary>Get the XML document </summary>
        /// <returns> IByteBuffer
        /// </returns>
        public IByteBuffer getXML()
        {
            return XMLDoc;
        }
        private long handle_utf8(long temp, int offset)
        {
            int a, d, c;
            long val;

            switch (UTF8Char.byteCount((int)temp & 0xff))
            {
                case 2:
                    c = 0x1f;
                    d = 6;
                    a = 1;
                    break;

                case 3:
                    c = 0x0f;
                    d = 12;
                    a = 2;
                    break;

                case 4:
                    c = 0x07;
                    d = 18;
                    a = 3;
                    break;

                case 5:
                    c = 0x03;
                    d = 24;
                    a = 4;
                    break;

                case 6:
                    c = 0x01;
                    d = 30;
                    a = 5;
                    break;

                default:
                    throw new NavException("UTF 8 encoding error: should never happen");

            }

            val = (temp & c) << d;
            int i = a - 1;
            while (i >= 0)
            {
                temp = XMLDoc.byteAt(offset + a - i);
                if ((temp & 0xc0) != 0x80)
                    throw new NavException("UTF 8 encoding error: should never happen");
                val = val | ((temp & 0x3f) << ((i << 2) + (i << 1)));
                i--;
            }
            //currentOffset += a + 1;
            return val | (((long)(a + 1)) << 32);
        }

        private long handle_utf16be(int offset)
        {
            int val, temp = ((XMLDoc.byteAt(offset << 1)) << 8) | (XMLDoc.byteAt((offset << 1) + 1));
            if ((temp < 0xd800) || (temp > 0xdfff))
            {
                // not a high surrogate
                if (temp == '\r')
                {
                    if (XMLDoc.byteAt((offset << 1) + 3) == '\n' && XMLDoc.byteAt((offset << 1) + 2) == 0)
                    {
                        return '\n' | (2L << 32);
                    }
                    else
                    {
                        return '\n' | (1L << 32);
                    }
                }
                return temp | (1L << 32);
            }
            else
            {
                if (temp < 0xd800 || temp > 0xdbff)
                    throw new NavException("UTF 16 BE encoding error: should never happen");
                val = temp;
                temp = ((XMLDoc.byteAt((offset << 1) + 2)) << 8) | (XMLDoc.byteAt((offset << 1) + 3));
                if (temp < 0xdc00 || temp > 0xdfff)
                {
                    // has to be a low surrogate here
                    throw new NavException("UTF 16 BE encoding error: should never happen");
                }
                val = ((temp - 0xd800) << 10) + (val - 0xdc00) + 0x10000;
                return val | (2L << 32);
            }
            //goto case FORMAT_UTF_16LE;
        }
        private long handle_utf16le(int offset)
        {
            // implement UTF-16LE to UCS4 conversion
            int val, temp = (XMLDoc.byteAt((offset << 1) + 1)) << 8 | (XMLDoc.byteAt(offset << 1));
            if (temp < 0xdc00 || temp > 0xdfff)
            {
                // check for low surrogate
                if (temp == '\r')
                {
                    if (XMLDoc.byteAt((offset << 1) + 2) == '\n' && XMLDoc.byteAt((offset << 1) + 3) == 0)
                    {
                        return '\n' | (2L << 32);
                    }
                    else
                    {
                        return '\n' | (1L << 32);
                    }
                }
                return temp | (1L << 32);
            }
            else
            {
                if (temp < 0xd800 || temp > 0xdbff)
                    throw new NavException("UTF 16 LE encoding error: should never happen");
                val = temp;
                temp = (XMLDoc.byteAt((offset << 1) + 3)) << 8 | (XMLDoc.byteAt((offset << 1) + 2));
                if (temp < 0xdc00 || temp > 0xdfff)
                {
                    // has to be high surrogate
                    throw new NavException("UTF 16 LE encoding error: should never happen");
                }
                val = ((temp - 0xd800) << 10) + (val - 0xdc00) + 0x10000;
                return val | (2L << 32);
            }
        }
        //UPGRADE_NOTE: Respective javadoc comments were merged.  It should be changed in order to comply with .NET documentation conventions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1199'"
        /// <summary> Get the value of atTerminal
        /// This function only gets called in XPath eval
        /// </summary>
        /// <returns>
        /// </returns>
        /// <summary> Set the value of atTerminal
        /// This function only gets called in XPath eval
        /// when a step calls for @* or child::text()
        /// </summary>
        /// <param name="b">
        /// </param>
        protected internal bool AtTerminal
        {
            get
            {
                return atTerminal;
            }

            set
            {
                atTerminal = value;
            }

        }
        // Navigation directions
        public const int ROOT = 0;
        public const int PARENT = 1;
        public const int FIRST_CHILD = 2;
        public const int LAST_CHILD = 3;
        public const int NEXT_SIBLING = 4;
        public const int PREV_SIBLING = 5;

        // Navigation directions
        public const int R = 0;
        public const int P = 1;
        public const int FC = 2;
        public const int LC = 3;
        public const int NS = 4;
        public const int PS = 5;

        // token type definitions
        public const int TOKEN_STARTING_TAG = 0;
        public const int TOKEN_ENDING_TAG = 1;
        public const int TOKEN_ATTR_NAME = 2;
        public const int TOKEN_ATTR_NS = 3;
        public const int TOKEN_ATTR_VAL = 4;
        public const int TOKEN_CHARACTER_DATA = 5;
        public const int TOKEN_COMMENT = 6;
        public const int TOKEN_PI_NAME = 7;
        public const int TOKEN_PI_VAL = 8;
        public const int TOKEN_DEC_ATTR_NAME = 9;
        public const int TOKEN_DEC_ATTR_VAL = 10;
        public const int TOKEN_CDATA_VAL = 11;
        public const int TOKEN_DTD_VAL = 12;
        public const int TOKEN_DOCUMENT = 13;

        // encoding format definition here

        public const int FORMAT_ASCII = 0;
        public const int FORMAT_ISO_8859_1 = 1;
        public const int FORMAT_UTF8 = 2;
        
        public const int FORMAT_UTF_16LE = 64;
        public const int FORMAT_UTF_16BE = 63;




        // masks for obtaining various fields from a VTD token 
        private const long MASK_TOKEN_FULL_LEN = 0x000fffff00000000;
        private const long MASK_TOKEN_PRE_LEN = 0x000ff80000000000;
        private const long MASK_TOKEN_QN_LEN = 0x000007ff00000000;
        internal long MASK_TOKEN_OFFSET = 0x000000003fffffff;
        //UPGRADE_TODO: Literal detected as an unsigned long can generate compilation errors. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1175'"
        private const long MASK_TOKEN_TYPE = unchecked((long)0xf000000000000000);
        //UPGRADE_TODO: Literal detected as an unsigned long can generate compilation errors. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1175'"
        private const long MASK_TOKEN_DEPTH = 0x0ff0000000000000L;

        // tri-state variable for namespace lookup
        private const long MASK_TOKEN_NS_MARK = 0x00000000c0000000L;

        protected internal int rootIndex; // where the root element is at
        protected internal int nestingLevel;
        protected internal int[] context; // main navigation tracker aka context object
        protected internal bool atTerminal; // this variable is to make vn compatible with
        // xpath's data model


        // location cache part
        protected internal int l2upper;
        protected internal int l2lower;
        protected internal int l3upper;
        protected internal int l3lower;
        protected internal int l2index;
        protected internal int l3index;
        protected internal int l1index;

        // containers
        protected internal ILongBuffer vtdBuffer;
        protected internal ILongBuffer l1Buffer;
        protected internal ILongBuffer l2Buffer;
        protected internal IIntBuffer l3Buffer;
        private IByteBuffer XMLDoc;

        //private int recentNS; // most recently visited NS node, experiment for now
        // Hierarchical representation is an array of integers addressing elements tokens 
        private ContextBuffer contextStack;
        //protected internal ContextBuffer contextStack2; // this is reserved for XPath

        protected internal int LN; // record txt and attrbute for XPath eval purposes
        // the document encoding	     
        private int encoding;
        // for string to token comparison
        //protected internal int currentOffset;
        //protected internal int currentOffset2;

        // whether the navigation is namespace enabled or not. 
        protected internal bool ns;

        // intermediate buffer for push and pop purposes  
        private int[] stackTemp;
        protected internal int docOffset;
        // length of the document
        protected internal int docLen;
        protected internal int vtdSize; //vtd record count
        /// <summary> Initialize the VTD navigation object.</summary>
        /// <param name="RootIndex">int
        /// </param>
        /// <param name="maxDepth">int
        /// </param>
        /// <param name="encoding">int
        /// </param>
        /// <param name="NS"> boolean
        /// </param>
        /// <param name="x">byte[]
        /// </param>
        /// <param name="vtd">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l1">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l2">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l3">com.ximpleware.IIntBuffer
        /// </param>
        /// <param name="so">int  starting offset of the document(in byte)
        /// </param>
        /// <param name="length">int length of the document (in byte)
        /// </param>
        protected internal VTDNav(int RootIndex, int enc, bool NS, int depth, IByteBuffer x, ILongBuffer vtd, ILongBuffer l1, ILongBuffer l2, IIntBuffer l3, int so, int length)
        {
            // initialize all buffers
            if (l1 == null || l2 == null || l3 == null || vtd == null || x == null || depth < 0 || RootIndex < 0 || so < 0 || length < 0)
            {
                throw new System.ArgumentException();
            }

            l1Buffer = l1;
            l2Buffer = l2;
            l3Buffer = l3;
            vtdBuffer = vtd;
            XMLDoc = x;

            encoding = enc;
            //System.out.println("encoding " + encoding);
            rootIndex = RootIndex;
            nestingLevel = depth + 1;
            ns = NS; // namespace aware or not
            if (ns == false)
                MASK_TOKEN_OFFSET = 0x000000007fffffff;
            // this allows xml size to be 2GB 
            // if there is no namespace
            else
                MASK_TOKEN_OFFSET = 0x000000003fffffff;


            atTerminal = false; //this variable will only change value during XPath eval

            // initialize the context object
            context = new int[nestingLevel];
            //depth value is the first entry in the context because root is singular.
            context[0] = 0;
            //set the value to zero
            for (int i = 1; i < nestingLevel; i++)
            {
                context[i] = -1;
            }
            // currentOffset = 0;
            //contextStack = new ContextBuffer(1024, nestingLevel + 7);
            contextStack = new ContextBuffer(10, nestingLevel + 9);
            //contextStack2 = new ContextBuffer(10, nestingLevel + 9);
            stackTemp = new int[nestingLevel + 9];

            // initial state of LC variables
            l1index = l2index = l3index = -1;
            l2lower = l3lower = -1;
            l2upper = l3upper = -1;
            docOffset = so;
            docLen = length;
            //System.out.println("offset " + offset + "  length " + length);
            //printL2Buffer();
            vtdSize = vtd.size();

            //recentNS = -1;
        }
        /// <summary> This method print out the current state info of the navigation object.
        /// It is for debugging purpose.
        /// </summary>
        public void dumpContext()
        {
            for (int i = 0; i < context.Length; i++)
            {
                System.Console.Out.WriteLine("context[" + i + "] ==>" + context[i]);
            }
            try
            {
                System.Console.Out.WriteLine("element name -->" + toRawString(getCurrentIndex()));
            }
            catch (NavException e)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Throwable.toString' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                System.Console.Out.WriteLine("toString exception condition occurred " + e);
            }
        }
        /// <summary> Get the token index of the attribute value given an attribute name.     </summary>
        /// <returns> int  (-1 if no such attribute name exists)
        /// </returns>
        /// <param name="an">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if an is null
        /// </exception>
        public int getAttrVal(System.String an)
        {
            //int size = vtdBuffer.size();
            if (context[0] == -1)
                return -1;
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;

            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;
            if (ns == false)
            {
                while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                {
                    if (matchRawTokenString(index, an))
                    {
                        // ns node visible only ns is disabled
                        return index + 1;
                    }
                    index += 2;
                    if (index >= vtdSize)
                        break;
                    type = getTokenType(index);
                }
            }
            else
            {
                while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                {
                    if (type == TOKEN_ATTR_NAME && matchRawTokenString(index, an))
                    {
                        // ns node visible only ns is disabled
                        return index + 1;
                    }
                    index += 2;
                    if (index >= vtdSize)
                        break;
                    type = getTokenType(index);
                }
            }
            return -1;
        }
        /// <summary> Get the token index of the attribute value of given URL and local name.
        /// If ns is not enabled, the lookup will return -1, indicating a no-found.
        /// Also namespace nodes are invisible using this method.
        /// One can't use * to indicate any name space because * is ambiguous!!
        /// </summary>
        /// <returns> int (-1 if no matching attribute found)
        /// </returns>
        /// <param name="URL">java.lang.String  (Name space URL)
        /// </param>
        /// <param name="ln">java.lang.String   (local name)
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if s is null
        /// </exception>
        public int getAttrValNS(System.String URL, System.String ln)
        {
            if (ns == false)
                return -1;
            if (URL == null)
                return getAttrVal(ln);
            int size = vtdBuffer.size();
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            // point to the token next to the element tag
            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;
            while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
            {
                int i = getTokenLength(index);
                int offset = getTokenOffset(index);
                int preLen = (i >> 16) & 0xffff;
                int fullLen = i & 0xffff;
                if (preLen != 0 && matchRawTokenString(offset + preLen + 1, fullLen - preLen - 1, ln) && resolveNS(URL, offset, preLen))
                {
                    return index + 1;
                }
                index += 2;
                if (index >= vtdSize)
                    break;
                type = getTokenType(index);
            }
            return -1;
        }

       
        /// <summary> Get the next char unit which gets decoded automatically</summary>
        /// <returns> int
        /// </returns>
        private int getCharUnit(int offset)
        {
            return (encoding <= 2)
                ? XMLDoc.byteAt(offset)
                : ((encoding == FORMAT_UTF_16BE)
            ? (XMLDoc.byteAt(offset << 1)
            << 8 | XMLDoc.byteAt((offset << 1) + 1)) :
            (XMLDoc.byteAt((offset << 1) + 1)
            << 8 | XMLDoc.byteAt(offset << 1)));
        }
        /// <summary> Get the depth value of a token (>=0).</summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        public int getTokenDepth(int index)
        {
            //int i = (int) vtdBuffer.longAt(index);           
            //i = ((i & 0x0f) << 4) | ((i & 0xf000) >> 12); 
            int i = (int)((vtdBuffer.longAt(index) & MASK_TOKEN_DEPTH) >> 52);

            if (i != 255)
                return i;
            return -1;
        }
        /// <summary> Get the token length at the given index value
        /// please refer to VTD spec for more details
        /// Length is in terms of the UTF char unit
        /// For prefixed tokens, it is the qualified name length.
        /// When ns is not enabled, return the full name length for attribute name and element name
        /// When ns is enabled, return an int with upper 16 bit for prefix length, lower 16 bit for qname length 
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        public int getTokenLength(int index)
        {
            int type = getTokenType(index);
            int depth;
            //int val;
            int len = 0, j;
            long l;

            switch (type)
            {

                case TOKEN_ATTR_NAME:
                case TOKEN_ATTR_NS:
                case TOKEN_STARTING_TAG:
                    l = vtdBuffer.longAt(index);
                    j = swap_bytes((int)l);
                    //return (this.ns == false)
                    //    ? j & 0xfffff
                    //    : ((j & 0xff800) << 5) | (j & 0x7ff);

                    return (ns == false) ? (int)((l & MASK_TOKEN_QN_LEN) >> 32) : ((int)((l & MASK_TOKEN_QN_LEN) >> 32) | ((int)((l & MASK_TOKEN_PRE_LEN) >> 32) << 5));

                case TOKEN_CHARACTER_DATA:
                case TOKEN_CDATA_VAL:
                case TOKEN_COMMENT:  // make sure this is total length
                    depth = getTokenDepth(index);
                    do
                    {
                        len = len + (int)((vtdBuffer.longAt(index) & MASK_TOKEN_FULL_LEN) >> 32);
                        //len = len + (swap_bytes((int)vtdBuffer.longAt(index)) & 0xfffff);
                        index++;
                    }
                    while (index < vtdSize && depth == getTokenDepth(index) && type == getTokenType(index));
                    //if (int k=0)
                    return len;

                default:
                    return (int)((vtdBuffer.longAt(index) & MASK_TOKEN_FULL_LEN) >> 32);
                //return swap_bytes((int)vtdBuffer.longAt(index)) & 0xfffff;


            }
            /*if (encoding<3)
            return val;
            else
            return val<<1;*/
        }
        /// <summary> Get the starting offset of the token at the given index.</summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="">
        /// </exception>
        public int getTokenOffset(int index)
        {
            //return (context[0] != 0)
            //    ? (int) (vtdBuffer.longAt(context[context[0]]) & MASK_TOKEN_OFFSET)
            //    : (int) (vtdBuffer.longAt(rootIndex) & MASK_TOKEN_OFFSET);
            return (int)(vtdBuffer.longAt(index) & MASK_TOKEN_OFFSET);
            //return swap_bytes((int) ((vtdBuffer.longAt(index) & MASK_TOKEN_OFFSET)>>32));
        }
        /// <summary> Get the token type of the token at the given index value.
        /// Creation date: (11/16/03 6:41:51 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="">
        /// </exception>
        public int getTokenType(int index)
        {
            return (int)((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf;
            //return ((int)vtdBuffer.longAt(index) & 0xf0) >> 4;
        }
        /// <summary> Test whether current element has an attribute with the matching name.
        /// "*" will match any attribute name, therefore is a test whether there is any attribute at all
        /// if namespace is disabled, this function will not distinguish between ns declaration and attribute 
        /// otherwise, ns tokens are invisible
        /// Creation date: (11/16/03 5:50:26 PM)
        /// </summary>
        /// <returns> boolean (true if such an attribute exists)
        /// </returns>
        /// <param name="an">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if an is null
        /// </exception>
        public bool hasAttr(System.String an)
        {
            if (context[0] == -1)
                return false;
            int size = vtdBuffer.size();

            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            if (index >= size)
                return false;
            int type = getTokenType(index);
            if (ns == false)
            {
                if (an.Equals("*"))
                {
                    if (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                        return true;
                    else
                        return false;
                }
                else
                {
                    while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                    {
                        // ns tokens becomes visible
                        if (matchRawTokenString(index, an))
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
            }
            else
            {
                if (an.Equals("*"))
                {
                    while (index < size && (getTokenType(index) == TOKEN_ATTR_NAME || getTokenType(index) == TOKEN_ATTR_NS))
                    {
                        if (type == TOKEN_ATTR_NAME)
                            // TOKEN_ATTR_NS is invisible when ns == true
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
                else
                {
                    while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                    {
                        if (type == TOKEN_ATTR_NAME && matchRawTokenString(index, an))
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
            }
        }
        /// <summary> Test whether the current element has an attribute with 
        /// matching namespace URL and localname.
        /// If ns is false, return false immediately
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">java.lang.String (namespace URL)
        /// </param>
        /// <param name="ln">java.lang.String  (localname )
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// </exception>
        public bool hasAttrNS(System.String URL, System.String ln)
        {
            return (getAttrValNS(URL, ln) != -1);
        }
        /// <summary> Test the token type, to see if it is a starting tag.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        private bool isElement(int index)
        {
            return (((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf) == TOKEN_STARTING_TAG;
            //return (((((int)vtdBuffer.longAt(index)) & 0xf0) >> 4) == TOKEN_STARTING_TAG);
        }

        /// <summary> Test the token type, to see if it is a starting tag 
        /// or document token (introduced in 1.0).
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        private bool isElementOrDocument(int index)
        {
            long i = (((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf);
            //int i = ((((int)vtdBuffer.longAt(index) & 0xf0) >> 4));

            return (i == TOKEN_STARTING_TAG || i == TOKEN_DOCUMENT);
        }
        /// <summary> Test whether ch is a white space character or not.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="ch">int
        /// </param>
        private bool isWS(int ch)
        {
            return (ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r');
        }


        /// <summary> This method is similar to getElementByName in DOM except it doesn't
        /// return the nodeset, instead it iterates over those nodes. Notice that this method
        /// is called by the "iterate" method in the Autopilot class.
        /// "*" will match any element
        /// Creation date: (12/2/03 2:31:20 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="dp">int    (The depth of the starting position before iterating)
        /// </param>
        /// <param name="en">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception is signaled if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because VTD records can be generated by another
        /// machine from a load-balancer.
        /// null element name allowed represent node()in XPath;
        /// </exception>
        protected internal bool iterate(int dp, System.String en, bool special)
        {
            // the navigation doesn't rely on LC
            // get the current depth
            int index = getCurrentIndex() + 1;
            //int size = vtdBuffer.size();
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    if (depth > dp)
                    {
                        context[0] = depth;
                        if (depth > 0)
                            context[depth] = index;
                        if (special || matchElement(en))
                        {
                            if (dp < 4)
                                resolveLC();
                            return true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                index++;
            }
            return false;
        }
        /// <summary> This method is similar to getElementByName in DOM except it doesn't
        /// return the nodeset, instead it iterates over those nodes .
        /// When URL is "*" it will match any namespace
        /// if ns is false, return false immediately
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="dp">int    (The depth of the starting position before iterating)
        /// </param>
        /// <param name="URL"> java.lang.String
        /// </param>
        /// <param name="ln"> java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because VTD records can be generated by another
        /// machine from a load-balancer..
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// example
        /// 
        /// int depth = nv.getCurrentDepth()
        /// while(iterateNS(depth, "www.url.com","node_name")){
        /// push(); // store the current position
        /// //move position safely
        /// pop();  // load the position
        /// }
        /// </exception>
        protected internal bool iterateNS(int dp, System.String URL, System.String ln)
        {
            if (ns == false)
                return false;

            int index = getCurrentIndex() + 1;
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    if (depth > dp)
                    {
                        context[0] = depth;
                        if (depth > 0)
                            context[depth] = index;
                        if (matchElementNS(URL, ln))
                        {
                            if (dp < 4)
                                resolveLC();
                            return true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                index++;
            }
            return false;
        }

        /// <summary> Test if the current element matches the given name.
        /// Creation date: (11/26/03 2:09:43 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="en">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">If the underlying raw char representation has errors.
        /// </exception>
        /// <exception cref="IllegalArguementException">if en is null
        /// </exception>
        public bool matchElement(System.String en)
        {
            if (en == null)
                throw new System.ArgumentException(" can't match Element name ");

            if (en.Equals("*") && context[0] != -1)
                return true;
            if (context[0] == -1)
                return false;
            return matchRawTokenString((context[0] == 0) ? rootIndex : context[context[0]], en);
        }
        /// <summary> Test whether the current element matches the given namespace URL and localname.
        /// URL, when set to "*", matches any namespace (including null), when set to null, defines a "always-no-match"
        /// ln is the localname that, when set to *, matches any localname
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">java.lang.String
        /// </param>
        /// <param name="ln">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown entity.
        /// </exception>
        /// <exception cref="java.lang.IllegalArgumentException"> if ln == null
        /// </exception>
        public bool matchElementNS(System.String URL, System.String ln)
        {
            if (context[0] == -1)
                return false;
            int i = getTokenLength((context[0] != 0) ? context[context[0]] : rootIndex);
            int offset = getTokenOffset((context[0] != 0) ? context[context[0]] : rootIndex);
            int preLen = (i >> 16) & 0xffff;
            int fullLen = i & 0xffff;

            if (ln.Equals("*") || ((preLen != 0) ? matchRawTokenString(offset + preLen + 1, fullLen - preLen - 1, ln) : matchRawTokenString(offset, fullLen, ln)))
            {
                // no prefix, search for xmlns
                if (((URL != null) ? URL.Equals("*") : false) || (resolveNS(URL, offset, preLen) == true))
                    return true;
            }
            return false;
        }
        /// <summary> Match a string against a token with given offset and len, entities doesn't get resolved.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="offset">int
        /// </param>
        /// <param name="len">int
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
       
        private bool matchRawTokenString(int offset, int len, System.String s)
        {
            return compareRawTokenString(offset, len, s) == 0;
        }
        /// <summary> Match the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets matched against
        /// This method has to take care of the underlying encoding conversion
        /// but it <em> doesn't </em> resolve entity reference in the underlying document
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int   (index into the VTD token buffer)
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// 
        public bool matchRawTokenString(int index, System.String s)
        {
            int type = getTokenType(index);
            int len = (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS) ? getTokenLength(index) & 0xffff : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareRawTokenString(getTokenOffset(index), len, s)==0;
        }
        /// <summary> Match a string with a token represented by a long (upper 32 len, lower 32 offset).</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="l">long
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// 
        private bool matchRawTokenString(long l, System.String s)
        {
            int len = (int)((l & MASK_TOKEN_FULL_LEN) >> 32);
            // a little hardcode is always bad
            //currentOffset = (int)l;
            return compareRawTokenString((int)l, len, s)==0;
        }
        /// <summary> Match a string against a token with given offset and len, entities get resolved properly.
        /// Creation date: (11/24/03 1:37:42 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="offset">int
        /// </param>
        /// <param name="len">int
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if s is null
        /// </exception>
        private bool matchTokenString(int offset, int len, System.String s)
        {
            return compareTokenString(offset, len, s) == 0;
        }
        /// <summary> Match the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets matched against
        /// This method has to take care of the underlying encoding conversion
        /// as well as entity reference comparison
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        
        public bool matchTokenString(int index, System.String s)
        {
            int type = getTokenType(index);
            int len = (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS) ? getTokenLength(index) & 0xffff : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareTokenString(getTokenOffset(index), len, s)==0;
        }
        /// <summary> Match a string against a "non-extractive" token represented by a long (upper 32 len, lower 32 offset).</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="l">long
        /// </param>
        /// <param name="s">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        

        private bool matchTokenString(long l, System.String s)
        {
            int len = (int)(l >> 32) & 0xfffff;
            //int len = swap_bytes((int)(l>>32)) & 0xfffff;
            return compareTokenString((int)l, len, s)==0;
        }


        /// <summary> Evaluate the namespace indicator in bit 31 and bit 30.
        /// Creation date: (11/27/03 5:38:51 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="i">int
        /// </param>
        private int NSval(int i)
        {

            return (int)(vtdBuffer.longAt(i) & MASK_TOKEN_NS_MARK);
        }
        /// <summary>
        /// overWrite is introduced in version 2.0 that allows you to 
        /// directly overwrite the XML content if the token is long enough
        /// If the operation is successful, white spaces will be used to fill
        /// the available token space, and there will be no need to regenerate
        /// the VTD and LCs
        /// <em> The current version (2.0) only allows overwrites on attribute value,
        /// character data, and CDATA</em>
        /// 
        /// Consider the XML below:
        ///  <a>  good </a> 
        /// After overwriting the token "good" with "bad," the new XML looks
        /// like:
        ///  <a>  bad  </a>
        /// as you can see, "goo" is replaced with "bad" character-by-character, 
        /// and the remaining "d" is replace with a white space  
        ///  
        /// </summary>
        /// <param name="index"></param>
        /// <param name="ba"></param>
        /// <returns></returns>
        public bool overWrite(int index, byte[] ba)
        {
            return overWrite(index, ba, 0, ba.Length);
        }
        /// <summary>
        ///  overWrite is introduced in version 2.0 that allows you to 
        /// directly overwrite the XML content if the token is long enough
	    /// If the operation is successful, white spaces will be used to fill
	    /// the available token space, and there will be no need to regenerate
	    /// the VTD and LCs
	    /// <em> The current version (2.0) only allows overwrites on attribute value,
	    /// character data, and CDATA</em>
	    /// 
	    /// Consider the XML below:
	    ///  <a>  good </a> 
	    /// After overwriting the token "good" with "bad," the new XML looks
	    /// like:
	    ///  <a>  bad  </a>
	    /// as you can see, "goo" is replaced with "bad" character-by-character, 
	    /// and the remaining "d" is replace with a white space  
	    ///  
        /// </summary>
        /// <param name="index"></param>
        /// <param name="ba"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <returns>status of overwrite</returns>
        public bool overWrite(int index, byte[] ba, int offset, int len)
        {
            if (ba == null
                    || index >= this.vtdSize
                    || offset < 0
                    || offset + len > ba.Length)
                throw new ArgumentException("Illegal argument for overwrite");
            if (encoding >= VTDNav.FORMAT_UTF_16BE
                    && (((len & 1) == 1)
                    || ((offset & 1) == 1)))
            {
                // for UTF 16, len and offset must be integer multiple
                // of 2
                return false;
            }
            int t = getTokenType(index);
            if (t == VTDNav.TOKEN_CHARACTER_DATA
                    || t == VTDNav.TOKEN_ATTR_VAL
                    || t == VTDNav.TOKEN_CDATA_VAL)
            {
                int length = getTokenLength(index);
                if (length < len)
                    return false;
                int os = getTokenOffset(index);
                int temp = length - len;
                // get XML doc
                Array.Copy(ba, offset, XMLDoc.getBytes(), os, len);
                for (int k = 0; k < temp; )
                {
                    if (encoding < VTDNav.FORMAT_UTF_16BE)
                    {
                        // write white spaces
                        XMLDoc.getBytes()[os + len+k] = (byte)' ';
                        k++;
                    }
                    else
                    {
                        if (encoding == VTDNav.FORMAT_UTF_16BE)
                        {
                            XMLDoc.getBytes()[os + len + k] = 0;
                            XMLDoc.getBytes()[os + len + k + 1] = (byte)' ';
                        }
                        else
                        {
                            XMLDoc.getBytes()[os + len + k + 1] = 0;
                            XMLDoc.getBytes()[os + len + k] = (byte)' ';
                        }
                        k += 2;
                    }
                }
                return true;
            }
            return false;
        }
        /// <summary> Convert a vtd token into a double.
        /// Creation date: (12/8/03 2:28:31 PM)
        /// </summary>
        /// <returns> double
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public double parseDouble(int index)
        {
            //if (matchTokenString()
            int offset = getTokenOffset(index);
            long l = 0;
            int end = offset + getTokenLength(index);
            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            bool expneg = false;
            int ch;
            //past the last one by one

            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            while (offset < end)
            {
                // trim leading whitespaces
                if (!isWS(ch))
                    break;
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (offset > end)
                // all whitespace
                return System.Double.NaN;

            bool neg = (ch == '-');

            if (ch == '-' || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//get another one if it is sign.

            //left part of decimal
            double left = 0;
            while (offset <= end)
            {
                //must be <= since we get the next one at last.

                //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int dig = (int)System.Char.GetNumericValue((char)ch); //only consider decimal
                if (dig < 0)
                    break;

                left = left * 10 + dig;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //right part of decimal
            double right = 0;
            double scale = 1;
            if (ch == '.')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    right = right * 10 + dig;
                    scale *= 10;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
            }

            //exponent
            long exp = 0;
            if (ch == 'E' || ch == 'e')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
                expneg = (ch == '-'); //sign for exp
                if (ch == '+' || ch == '-')
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                } //skip the +/- sign

                int cur = offset;
                //remember the indx, used to find a invalid number like 1.23E

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    exp = exp * 10 + dig;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
                if (cur == offset)
                    return System.Double.NaN;
                //found a invalid number like 1.23E

                //if (expneg)
                //	exp = (-exp);
            }

            //anything left must be space
            while (offset <= end)
            {
                if (!isWS(ch))
                    return System.Double.NaN;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            double v = (double)left;
            if (right != 0)
                v += ((double)right) / (double)scale;

            if (exp != 0)
                v = (expneg) ? v / (System.Math.Pow(10, exp)) : v * System.Math.Pow(10, exp);

            return ((neg) ? (-v) : v);
        }

        /// <summary> Convert a vtd token into a float.
        /// we assume token type to be attr val or character data
        /// Creation date: (12/8/03 2:28:18 PM)
        /// </summary>
        /// <returns> float
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public float parseFloat(int index)
        {

            int offset = getTokenOffset(index);
            long l = 0;
            int end = offset + getTokenLength(index);
            //past the last one by one
            int t = getTokenType(index);
            int ch;
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            while (offset <= end)
            {
                // trim leading whitespaces
                if (!isWS(ch))
                    break;
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (offset > end)
                // all whitespace
                throw new NavException("Empty string");

            bool neg = (ch == '-');

            if (ch == '-' || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            } //get another one if it is sign.

            //left part of decimal
            long left = 0;
            while (offset <= end)
            {
                //must be <= since we get the next one at last.

                //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int dig = (int)System.Char.GetNumericValue((char)ch); //only consider decimal
                if (dig < 0)
                    break;

                left = left * 10 + dig;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //right part of decimal
            long right = 0;
            long scale = 1;
            if (ch == '.')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    right = right * 10 + dig;
                    scale *= 10;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
            }

            //exponent
            long exp = 0;
            if (ch == 'E' || ch == 'e')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
                bool expneg = (ch == '-'); //sign for exp
                if (ch == '+' || ch == '-')
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                } //skip the +/- sign

                int cur = offset;
                //remember the indx, used to find a invalid number like 1.23E

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    exp = exp * 10 + dig;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }

                if (cur == offset)
                    return System.Single.NaN;
                //found a invalid number like 1.23E

                if (expneg)
                    exp = (-exp);
            }

            //anything left must be space
            while (offset <= end)
            {
                if (!isWS(ch))
                    throw new NavException(toString(index));

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            double v = (double)left;
            if (right != 0)
            {
                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                v += ((double)right) / (double)scale;
            }

            if (exp != 0)
                v = v * System.Math.Pow(10, exp);


            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            float f = (float)v;

            //try to handle overflow/underflow
            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            if (v >= (double)System.Single.MaxValue)
                f = System.Single.MaxValue;
            else
            {
                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                //UPGRADE_TODO: The equivalent in .NET for field 'java.lang.Float.MIN_VALUE' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                if (v <= (double)System.Single.Epsilon)
                {
                    //UPGRADE_TODO: The equivalent in .NET for field 'java.lang.Float.MIN_VALUE' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    f = System.Single.Epsilon;
                }
            }
            if (neg)
                f = -f;
            return f;
        }
        /// <summary> Convert a vtd token into an int.
        /// This method will automatically strip off the leading and trailing
        /// we assume token type to be attr val or character data
        /// zero, unlike Integer.parseInt(int index)
        /// 
        /// Creation date: (12/8/03 2:32:22 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public int parseInt(int index)
        {
            return parseInt(index, 10);
        }
        /// <summary> Convert a vtd token into an int, with the given radix.
        /// we assume token type to be attr val or character data
        /// the first char can be either '+' or '-'
        /// Creation date: (12/16/03 1:21:20 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="radix">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        protected internal int parseInt(int index, int radix)
        {
            if (radix < 2 || radix > 36)
                throw new System.FormatException("radix " + radix + " out of valid range");
            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            int offset = getTokenOffset(index);
            int endOffset = offset + getTokenLength(index);
            int ch;
            long l;
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            // trim leading whitespaces
            while ((ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r') && (offset <= endOffset))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            if (offset > endOffset)
                // all whitespace
                throw new System.FormatException(" empty string");

            bool neg = (ch == '-');
            if (neg || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//skip sign

            long result = 0;
            //long pos = 1;
            while (offset <= endOffset)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int digit = (int)System.Char.GetNumericValue((char)ch);
                if (digit < 0)
                    break;

                //Note: for binary we can simply shift to left to improve performance
                result = result * radix + digit;
                //pos *= radix;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (result > System.Int32.MaxValue)
                throw new System.FormatException("Overflow: " + toString(index));

            // take care of the trailing
            while (offset <= endOffset && isWS(ch))
            {

                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);

            }
            if (offset == (endOffset + 1))
                return (int)((neg) ? (-result) : result);
            else
                throw new System.FormatException(toString(index));
        }
        /// <summary> Convert a vtd token into a long.
        /// we assume token type to be attr val or character data
        /// Creation date: (12/8/03 2:32:59 PM)
        /// </summary>
        /// <returns> long
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public long parseLong(int index)
        {
            return parseLong(index, 10);
        }
        /// <summary> Convert a vtd token into a long, with the given radix.
        /// the first char can be either '+' or '-', leading and trailing will be stripped
        /// we assume token type to be attr val or character data
        /// Creation date: (12/17/03 1:51:06 PM)
        /// </summary>
        /// <returns> long
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="radix">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        protected internal long parseLong(int index, int radix)
        {
            if (radix < 2 || radix > 36)
                throw new System.FormatException("radix " + radix + " out of valid range");

            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);

            int offset = getTokenOffset(index);
            int endOffset = offset + getTokenLength(index);
            long l;
            int ch;

            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            // trim leading whitespaces
            while ((ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r') && (offset <= endOffset))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            if (offset > endOffset)
                // all whitespace
                throw new System.FormatException(" empty string");

            bool neg = (ch == '-');
            if (neg || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//skip sign

            long result = 0;
            //long pos = 1;
            while (offset <= endOffset)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int digit = (int)System.Char.GetNumericValue((char)ch);
                if (digit < 0)
                    break;

                //Note: for binary we can simply shift to left to improve performance
                result = result * radix + digit;
                //pos *= radix;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (result > System.Int64.MaxValue)
                throw new System.FormatException("Overflow: " + toString(index));

            // take care of the trailing
            while (offset <= endOffset && isWS(ch))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }
            if (offset == (endOffset + 1))
                return (long)((neg) ? (-result) : result);
            else
                throw new System.FormatException(toString(index));
        }
        /// <summary> Load the context info from ContextBuffer.
        /// Info saved including LC and current state of the context 
        /// Creation date: (11/16/03 6:59:20 PM)
        /// </summary>
        /// <ret>  boolean </ret>
        public bool pop()
        {
            bool b = contextStack.load(stackTemp);
            if (b == false)
                return false;
            for (int i = 0; i < nestingLevel; i++)
            {
                context[i] = stackTemp[i];
            }

            l1index = stackTemp[nestingLevel];
            l2index = stackTemp[nestingLevel + 1];
            l3index = stackTemp[nestingLevel + 2];
            l2lower = stackTemp[nestingLevel + 3];
            l2upper = stackTemp[nestingLevel + 4];
            l3lower = stackTemp[nestingLevel + 5];
            l3upper = stackTemp[nestingLevel + 6];
            atTerminal = (stackTemp[nestingLevel + 7] == 1);
            LN = stackTemp[nestingLevel + 8];
            return true;
        }

    
       
        /// <summary> Store the context info into the ContextBuffer.
        /// Info saved including LC and current state of the context 
        /// Creation date: (11/16/03 7:00:27 PM)
        /// </summary>
        public void push()
        {

            for (int i = 0; i < nestingLevel; i++)
            {
                stackTemp[i] = context[i];
            }
            stackTemp[nestingLevel] = l1index;
            stackTemp[nestingLevel + 1] = l2index;
            stackTemp[nestingLevel + 2] = l3index;
            stackTemp[nestingLevel + 3] = l2lower;
            stackTemp[nestingLevel + 4] = l2upper;
            stackTemp[nestingLevel + 5] = l3lower;
            stackTemp[nestingLevel + 6] = l3upper;
            if (atTerminal)
                stackTemp[nestingLevel + 7] = 1;
            else
                stackTemp[nestingLevel + 7] = 0;
            stackTemp[nestingLevel + 8] = LN;
            contextStack.store(stackTemp);
        }
    

       


    
        /// <summary> Sync up the current context with location cache.
        /// This operation includes finding out l1index, l2index, 
        /// l3index and restores upper and lower bound info
        /// To improve efficieny this method employs some heuristic search algorithm.
        /// The result is that it is quite close to direct access.
        /// Creation date: (11/16/03 7:44:53 PM)
        /// </summary>
        /// <returns> int  The index of the NS URL
        /// </returns>
        private void resolveLC()
        {
            int temp;
            if (context[0] <= 0)
                return;
            if (l1index < 0 || l1index >= l1Buffer.size() || context[1] != l1Buffer.upper32At(l1index))
            {
                if (l1index >= l1Buffer.size() || l1index < 0)
                {
                    l1index = 0;
                }
                if (l1index + 1 < l1Buffer.size() && context[1] != l1Buffer.upper32At(l1index + 1))
                {
                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                    int init_guess = (int)(l1Buffer.size() * ((float)context[1] / vtdBuffer.size()));
                    if (l1Buffer.upper32At(init_guess) > context[1])
                    {
                        while (l1Buffer.upper32At(init_guess) != context[1])
                        {
                            init_guess--;
                        }
                    }
                    else if (l1Buffer.upper32At(init_guess) < context[1])
                    {
                        while (l1Buffer.upper32At(init_guess) != context[1])
                        {
                            init_guess++;
                        }
                    }
                    l1index = init_guess;
                }
                else
                {
                    if (context[1] >= l1Buffer.upper32At(l1index))
                    {
                        while (context[1] != l1Buffer.upper32At(l1index) && l1index < l1Buffer.size())
                        {
                            l1index++;
                        }
                    }
                    else
                    {
                        while (context[1] != l1Buffer.upper32At(l1index) && l1index >= 0)
                        {
                            l1index--;
                        }
                    }
                }
                //	l1index = l1index + 1;
                // for iterations, l1index+1 is the logical next value for l1index
            }
            if (context[0] == 1)
                return;

            temp = l1Buffer.lower32At(l1index);
            if (l2lower != temp)
            {
                l2lower = temp;
                // l2lower shouldn't be -1 !!!! l2lower and l2upper always get
                // resolved simultaneously
                l2index = l2lower;
                l2upper = l2Buffer.size() - 1;
                for (int i = l1index + 1; i < l1Buffer.size(); i++)
                {
                    temp = l1Buffer.lower32At(i);
                    if (temp != -1)
                    {
                        l2upper = temp - 1;
                        break;
                    }
                }
            } // intelligent guess again ??

            if (l2index < 0 || l2index >= l2Buffer.size() || context[2] != l2Buffer.upper32At(l2index))
            {

                if (l2index >= l2Buffer.size() || l2index < 0)
                    l2index = l2lower;
                if (l2index + 1 < l2Buffer.size() && context[2] == l2Buffer.upper32At(l2index + 1))
                    l2index = l2index + 1;
                else if (l2upper - l2lower >= 16)
                {
                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                    int init_guess = l2lower + (int)((l2upper - l2lower) * ((float)context[2] - l2Buffer.upper32At(l2lower)) / (l2Buffer.upper32At(l2upper) - l2Buffer.upper32At(l2lower)));
                    if (l2Buffer.upper32At(init_guess) > context[2])
                    {
                        while (context[2] != l2Buffer.upper32At(init_guess))
                            init_guess--;
                    }
                    else if (l2Buffer.upper32At(init_guess) < context[2])
                    {
                        while (context[2] != l2Buffer.upper32At(init_guess))
                            init_guess++;
                    }
                    l2index = init_guess;
                }
                else if (context[2] < l2Buffer.upper32At(l2index))
                {

                    while (context[2] != l2Buffer.upper32At(l2index))
                    {
                        l2index--;
                    }
                }
                else
                {
                    while (context[2] != l2Buffer.upper32At(l2index))
                        l2index++;
                }
            }

            if (context[0] == 2)
                return;

            temp = l2Buffer.lower32At(l2index);
            if (l3lower != temp)
            {
                //l3lower and l3upper are always together
                l3lower = temp;
                // l3lower shouldn't be -1
                l3index = l3lower;
                l3upper = l3Buffer.size() - 1;
                for (int i = l2index + 1; i < l2Buffer.size(); i++)
                {
                    temp = l2Buffer.lower32At(i);
                    if (temp != -1)
                    {
                        l3upper = temp - 1;
                        break;
                    }
                }
            }

            if (l3index < 0 || l3index >= l3Buffer.size() || context[3] != l3Buffer.intAt(l3index))
            {
                if (l3index >= l3Buffer.size() || l3index < 0)
                    l3index = l3lower;
                if (l3index + 1 < l3Buffer.size() && context[3] == l3Buffer.intAt(l3index + 1))
                    l3index = l3index + 1;
                else if (l3upper - l3lower >= 16)
                {
                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                    int init_guess = l3lower + (int)((l3upper - l3lower) * ((float)(context[3] - l3Buffer.intAt(l3lower)) / (l3Buffer.intAt(l3upper) - l3Buffer.intAt(l3lower))));
                    if (l3Buffer.intAt(init_guess) > context[3])
                    {
                        while (context[3] != l3Buffer.intAt(init_guess))
                            init_guess--;
                    }
                    else if (l3Buffer.intAt(init_guess) < context[3])
                    {
                        while (context[3] != l3Buffer.intAt(init_guess))
                            init_guess++;
                    }
                    l3index = init_guess;
                }
                else if (context[3] < l3Buffer.intAt(l3index))
                {
                    while (context[3] != l3Buffer.intAt(l3index))
                    {
                        l3index--;
                    }
                }
                else
                {
                    while (context[3] != l3Buffer.intAt(l3index))
                    {
                        l3index++;
                    }
                }
            }
        }
        /// <summary> Test whether the URL is defined in the scope. Null is allowed to
        /// indicate the name space is undefined. Creation date: (11/16/03 7:54:01
        /// PM)
        /// 
        /// </summary>
        /// <param name="URL">java.lang.String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown
        /// entity.
        /// </exception>
        protected internal int lookupNS()
        {
            if (context[0] == -1)
                throw new NavException("Can't lookup NS for document node");
            int i = getTokenLength((context[0] != 0) ? context[context[0]] : rootIndex);
            int offset = getTokenOffset((context[0] != 0) ? context[context[0]] : rootIndex);
            int preLen = (i >> 16) & 0xffff;
            return lookupNS(offset, preLen);

            //return resolveNS(URL, offset, preLen);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal int lookupNS(int offset, int len)
        {
            long l;
            bool hasNS = false;
            int size = vtdBuffer.size();
            // look for a match in the current hiearchy and return true
            for (int i = context[0]; i >= 0; i--)
            {
                int s = (i != 0) ? context[i] : rootIndex;
                switch (NSval(s))
                {

                    // checked the ns marking
                    case unchecked((int)0xc0000000):
                        s = s + 1;
                        if (s >= size)
                            break;
                        int type = getTokenType(s);

                        while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                        {
                            if (type == TOKEN_ATTR_NS)
                            {
                                // Get the token length
                                int temp = getTokenLength(s);
                                int preLen = ((temp >> 16) & 0xffff);
                                int fullLen = temp & 0xffff;
                                int os = getTokenOffset(s);
                                // xmlns found
                                if (temp == 5 && len == 0)
                                {
                                    return s + 1;
                                }
                                else if ((fullLen - preLen - 1) == len)
                                {
                                    // prefix length identical to local part of ns declaration
                                    bool a = true;
                                    for (int j = 0; j < len; j++)
                                    {
                                        if (getCharUnit(os + preLen + 1 + j) != getCharUnit(offset + j))
                                        {
                                            a = false;
                                            break;
                                        }
                                    }
                                    if (a == true)
                                    {
                                        return s + 1;
                                    }
                                }
                            }
                            //return (URL != null) ? true : false;
                            s += 2;
                            if (s >= size)
                                break;
                            type = getTokenType(s);
                        }
                        break;

                    case unchecked((int)0x80000000):
                        break;

                    default:  // check the ns existence, mark bit 31:30 to 11 or 10
                        int k = s + 1;
                        if (k >= size)
                            break;
                        type = getTokenType(k);

                        while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                        {
                            if (type == TOKEN_ATTR_NS)
                            {
                                // Get the token length
                                hasNS = true;
                                int temp = getTokenLength(k);
                                int preLen = ((temp >> 16) & 0xffff);
                                int fullLen = temp & 0xffff;
                                int os = getTokenOffset(k);
                                // xmlns found
                                if (temp == 5 && len == 0)
                                {
                                    l = vtdBuffer.longAt(s);
                                    hasNS = false;
                                    vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                                    return k + 1;

                                }
                                else if ((fullLen - preLen - 1) == len)
                                {
                                    // prefix length identical to local part of ns declaration
                                    bool a = true;
                                    for (int j = 0; j < len; j++)
                                    {
                                        if (getCharUnit(os + preLen + 1 + j) != getCharUnit(offset + j))
                                        {
                                            a = false;
                                            break;
                                        }
                                    }
                                    if (a == true)
                                    {
                                        l = vtdBuffer.longAt(s);
                                        //hasNS = false;
                                        vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                                        return k + 1;
                                    }
                                }
                            }
                            //return (URL != null) ? true : false;
                            k += 2;
                            if (k >= size)
                                break;
                            type = getTokenType(k);
                        }
                        l = vtdBuffer.longAt(s);
                        if (hasNS)
                        {
                            hasNS = false;
                            vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                        }
                        else
                        {
                            vtdBuffer.modifyEntry(s, l | unchecked((int)0x0000008000000000L));
                        }
                        break;

                }
            }
            return 0;
        }
        /// <summary> Test whether the URL is defined in the document.
        /// Null is allowed to indicate the name space should be undefined.
        /// Creation date: (11/16/03 7:54:01 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">java.lang.String
        /// </param>
        /// <param name="offset">(offset of the prefix)
        /// </param>
        /// <param name="len">   (length of the prefix)
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown entity.
        /// </exception>
        private bool resolveNS(System.String URL, int offset, int len)
        {
            int result = lookupNS(offset, len);
            switch (result)
            {
                case 0:
                    if (URL == null)
                        return true;
                    else
                        return false;
                default:
                    if (URL == null)
                        return false;
                    else
                        return matchTokenString(result, URL);
            }
        }
        /// <summary> A generic navigation method.
        /// Move the current to the element according to the direction constants
        /// If no such element, no position change and return false.
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are
        /// <pre>   			ROOT               0 </pre>	
        /// <pre> 		    PARENT  		   1 </pre>
        /// <pre>       	    FIRST_CHILD		   2 </pre>  
        /// <pre> 		    LAST_CHILD 		   3 </pre>
        /// <pre>    	  	    NEXT_SIBLING       4 </pre>
        /// <pre>      	    PREV_SIBLING       5 </pre>
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal.
        /// </exception>
        public bool toElement(int direction)
        {
            int size;
            switch (direction)
            {

                case ROOT:  // to document element!
                    if (context[0] != 0)
                    {
                        /*for (int i = 1; i <= context[0]; i++) {
                        context[i] = 0xffffffff;
                        }*/
                        context[0] = 0;
                    }
                    atTerminal = false;
                    l1index = l2index = l3index = -1;
                    return true;

                case PARENT:
                    if (atTerminal == true)
                    {
                        atTerminal = false;
                        return true;
                    }
                    if (context[0] > 0)
                    {
                        //context[context[0]] = context[context[0] + 1] = 0xffffffff;
                        context[context[0]] = -1;
                        context[0]--;
                        return true;
                    }
                    else if (context[0] == 0)
                    {
                        context[0] = -1; //to be compatible with XPath Data model
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                //goto case FIRST_CHILD;

                case FIRST_CHILD:
                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    switch (context[0])
                    {

                        case -1:
                            context[0] = 0;
                            return true;

                        case 0:
                            if (l1Buffer.size() > 0)
                            {
                                context[0] = 1;
                                l1index = (direction == FIRST_CHILD) ? 0 : (l1Buffer.size() - 1);
                                context[1] = l1Buffer.upper32At(l1index);
                                //(int) (vtdToken >> 32);
                                return true;
                            }
                            else
                                return false;
                        //goto case 1;

                        case 1:
                            l2lower = l1Buffer.lower32At(l1index);
                            if (l2lower == -1)
                            {
                                return false;
                            }
                            context[0] = 2;
                            l2upper = l2Buffer.size() - 1;
                            size = l1Buffer.size();
                            for (int i = l1index + 1; i < size; i++)
                            {
                                int temp = l1Buffer.lower32At(i);
                                if (temp != -1)
                                {
                                    l2upper = temp - 1;
                                    break;
                                }
                            }
                            //System.out.println(" l2 upper: " + l2upper + " l2 lower : " + l2lower);
                            l2index = (direction == FIRST_CHILD) ? l2lower : l2upper;
                            context[2] = l2Buffer.upper32At(l2index);
                            return true;


                        case 2:
                            l3lower = l2Buffer.lower32At(l2index);
                            if (l3lower == -1)
                            {
                                return false;
                            }
                            context[0] = 3;

                            l3upper = l3Buffer.size() - 1;
                            size = l2Buffer.size();
                            for (int i = l2index + 1; i < size; i++)
                            {
                                int temp = l2Buffer.lower32At(i);
                                if (temp != -1)
                                {
                                    l3upper = temp - 1;
                                    break;
                                }
                            }
                            //System.out.println(" l3 upper : " + l3upper + " l3 lower : " + l3lower);
                            l3index = (direction == FIRST_CHILD) ? l3lower : l3upper;
                            context[3] = l3Buffer.intAt(l3index);

                            return true;


                        default:
                            if (direction == FIRST_CHILD)
                            {
                                size = vtdBuffer.size();
                                int index = context[context[0]] + 1;
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;

                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        //int depth = (((int)temp & 0x0f) << 4)
                                        //    | (((int)temp & 0xf000) >> 12);

                                        if (depth <= context[0])
                                        {
                                            return false;
                                        }
                                        else if (depth == (context[0] + 1))
                                        {
                                            context[0] += 1;
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }

                                    index++;
                                } // what condition  
                                return false;
                            }
                            else
                            {
                                int index = context[context[0]] + 1;
                                int last_index = -1;
                                size = vtdBuffer.size();
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                    //int depth = (((int)temp & 0x0f) << 4) | (((int)temp & 0xf000) >> 12);


                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;


                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        if (depth <= context[0])
                                        {
                                            break;
                                        }
                                        else if (depth == (context[0] + 1))
                                        {
                                            last_index = index;
                                        }
                                    }

                                    index++;
                                }
                                if (last_index == -1)
                                {
                                    return false;
                                }
                                else
                                {
                                    context[0] += 1;
                                    context[context[0]] = last_index;
                                    return true;
                                }
                            }
                        //break;

                    }
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    switch (context[0])
                    {

                        case -1:
                        case 0:
                            return false;

                        case 1:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l1index + 1 >= l1Buffer.size())
                                {
                                    return false;
                                }

                                l1index++; // global incremental
                            }
                            else
                            {
                                if (l1index - 1 < 0)
                                {
                                    return false;
                                }
                                l1index--; // global incremental
                            }
                            context[1] = l1Buffer.upper32At(l1index);
                            return true;

                        case 2:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l2index + 1 > l2upper)
                                {
                                    return false;
                                }
                                l2index++;
                            }
                            else
                            {
                                if (l2index - 1 < l2lower)
                                {
                                    return false;
                                }
                                l2index--;
                            }
                            context[2] = l2Buffer.upper32At(l2index);
                            return true;

                        case 3:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l3index + 1 > l3upper)
                                {
                                    return false;
                                }
                                l3index++;
                            }
                            else
                            {
                                if (l3index - 1 < l3lower)
                                {
                                    return false;
                                }
                                l3index--;
                            }
                            context[3] = l3Buffer.intAt(l3index);
                            return true;

                        default:
                            //int index = context[context[0]] + 1;

                            if (direction == NEXT_SIBLING)
                            {
                                int index = context[context[0]] + 1;
                                size = vtdBuffer.size();
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;


                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        //int depth = (((int)temp & 0x0f) << 4)
                                        //    | (((int)temp & 0xf000) >> 12);

                                        if (depth < context[0])
                                        {
                                            return false;
                                        }
                                        else if (depth == (context[0]))
                                        {
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }
                                    index++;
                                }
                                return false;
                            }
                            else
                            {
                                int index = context[context[0]] - 1;
                                while (index > context[context[0] - 1])
                                {
                                    // scan backforward
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;

                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        // int depth = (((int)temp & 0x0f) << 4) | (((int)temp & 0xf000) >> 12);

                                        /*if (depth < context[0]) {
                                        return false;
                                        } else */
                                        if (depth == (context[0]))
                                        {
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }
                                    index--;
                                } // what condition          	    
                                return false;
                            }
                        //break;

                    }
                //goto default;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> A generic navigation method.
        /// Move the current to the element according to the direction constants and the element name
        /// If no such element, no position change and return false.
        /// "*" matches any element
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are 	<br>
        /// <pre>		ROOT            0  </pre>
        /// <pre>		PARENT          1  </pre>
        /// <pre>		FIRST_CHILD     2  </pre>
        /// <pre>		LAST_CHILD      3  </pre>
        /// <pre>		NEXT_SIBLING    4  </pre>
        /// <pre>		PREV_SIBLING    5  </pre>
        /// <br>
        /// for ROOT and PARENT, element name will be ignored.
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <param name="en">String     
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal. Or there are errors 
        /// in underlying byte representation of the document
        /// </exception>
        /// <exception cref="IllegalArguementException">if en is null
        /// </exception>
        public bool toElement(int direction, System.String en)
        {
            //int size;
            int temp;
            int d;
            int val = 0;
            if (en == null)
                throw new System.ArgumentException(" Element name can't be null ");
            if (en.Equals("*"))
                return toElement(direction);
            switch (direction)
            {

                case ROOT:
                    return toElement(ROOT);


                case PARENT:
                    return toElement(PARENT);


                case FIRST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(FIRST_CHILD) == false)
                        return false;
                    // check current element name
                    if (matchElement(en) == false)
                    {
                        if (toElement(NEXT_SIBLING, en) == true)
                            return true;
                        else
                        {
                            //toParentElement();
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case LAST_CHILD;


                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(LAST_CHILD) == false)
                        return false;
                    if (matchElement(en) == false)
                    {
                        if (toElement(PREV_SIBLING, en) == true)
                            return true;
                        else
                        {
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            //toParentElement();
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];

                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    temp = context[d]; // store the current position

                    while (toElement(NEXT_SIBLING))
                    {
                        if (matchElement(en))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    temp = context[d]; // store the current position

                    while (toElement(PREV_SIBLING))
                    {
                        if (matchElement(en))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> A generic navigation method with namespace support.
        /// Move the current to the element according to the direction constants and the prefix and local names
        /// If no such element, no position change and return false.
        /// URL * matches any namespace, including undefined namespaces
        /// a null URL means hte namespace prefix is undefined for the element
        /// ln *  matches any localname
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are<br>
        /// <pre>		ROOT            0  </pre>
        /// <pre>		PARENT          1  </pre>
        /// <pre>		FIRST_CHILD     2  </pre>
        /// <pre>		LAST_CHILD      3  </pre>
        /// <pre>		NEXT_SIBLING    4  </pre>
        /// <pre>		PREV_SIBLING    5  </pre>
        /// <br>
        /// for ROOT and PARENT, element name will be ignored.
        /// If not ns enabled, return false immediately with no position change.
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <param name="en">String     
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal. Or there are errors 
        /// in underlying byte representation of the document
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// </exception>
        public bool toElementNS(int direction, System.String URL, System.String ln)
        {
            //int size;
            int temp;
            int val = 0;
            int d; // temp location
            if (ns == false)
                return false;
            switch (direction)
            {

                case ROOT:
                    return toElement(ROOT);


                case PARENT:
                    return toElement(PARENT);


                case FIRST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(FIRST_CHILD) == false)
                        return false;
                    // check current element name
                    if (matchElementNS(URL, ln) == false)
                    {
                        if (toElementNS(NEXT_SIBLING, URL, ln) == true)
                            return true;
                        else
                        {
                            //toParentElement();
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case LAST_CHILD;


                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(LAST_CHILD) == false)
                        return false;
                    if (matchElementNS(URL, ln) == false)
                    {
                        if (toElementNS(PREV_SIBLING, URL, ln) == true)
                            return true;
                        else
                        {
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            //toParentElement();
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    temp = context[d]; // store the current position
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    //if (d == 0)
                    //	return false;
                    while (toElement(NEXT_SIBLING))
                    {
                        if (matchElementNS(URL, ln))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    temp = context[d]; // store the current position
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    //if (d == 0)
                    //	return false;
                    while (toElement(PREV_SIBLING))
                    {
                        if (matchElementNS(URL, ln))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> This method normalizes a token into a string in a way that resembles DOM.
        /// The leading and trailing white space characters will be stripped.
        /// The entity and character references will be resolved
        /// Multiple whitespaces char will be collapsed into one.
        /// Whitespaces via entities will nonetheless be preserved.
        /// Creation date: (12/8/03 1:57:10 PM)
        /// </summary>
        /// <returns> java.lang.String
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="NavException">When the encoding has errors
        /// </exception>
        public System.String toNormalizedString(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA && type != TOKEN_ATTR_VAL)
                return toRawString(index);

            int len;
            if (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            if (len == 0)
                return "";
            int offset = getTokenOffset(index);
            int endOffset = len + offset - 1; // point to the last character
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            //System.String s = null;
            int ch;
            long l;

            // trim off the leading whitespaces

            while (true)
            {
                int temp = offset;
                {
                    l = getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                if (!isWS(ch))
                {
                    offset = temp;
                    break;
                }
            }

            bool d = false;
            while (offset <= endOffset)
            {
                l = getCharResolved(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
                if (isWS(ch) && getCharUnit(offset - 1) != ';')
                {
                    d = true;
                }
                else
                {
                    if (d == false)
                        sb.Append((char)ch);
                    // java only supports 16 bit unicode
                    else
                    {
                        sb.Append(' ');
                        sb.Append((char)ch);
                        d = false;
                    }
                }
            }

            return sb.ToString();
        }

        protected internal System.String toRawString(int os, int len)
        {
            int endOffset = len + os;
            int offset = os;
            long l;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);

            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l); // java only support 16 bit unit code
            }
            return sb.ToString();
        }
        /// <summary> Convert a token at the given index to a String, (built-in entity and char references not resolved)
        /// (entities and char references not expanded).
        /// Creation date: (11/16/03 7:28:49 PM)
        /// </summary>
        /// <returns> java.lang.String
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="NavException">When the encoding has errors
        /// </exception>
        public System.String toRawString(int index)
        {
            int type = getTokenType(index);
            int len;
            if (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);
            return toRawString(offset, len);
        }

        protected internal System.String toString(int os, int len)
        {
            int endOffset = len + os;
            int offset = os;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            //System.String s = null;
            long l;

            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l); // java only support 16 bit unit code
            }

            return sb.ToString();
        }
        /// <summary> Convert a token at the given index to a String, (entities and char references resolved).
        /// An attribute name or an element name will get the UCS2 string of qualified name 
        /// Creation date: (11/16/03 7:27:19 PM)
        /// </summary>
        /// <returns> java.lang.String
        /// </returns>
        /// <param name="int">index
        /// </param>
        /// <exception cref="NavException">
        /// </exception>
        public System.String toString(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA && type != TOKEN_ATTR_VAL)
                return toRawString(index);
            int len;
            if (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);

            return toString(offset, len);
        }

        /// <summary> This method compares two VTD tokens of VTDNav objects</summary>
        /// <param name="i1">
        /// </param>
        /// <param name="vn2">
        /// </param>
        /// <param name="i2">
        /// </param>
        /// <returns>
        /// 
        /// </returns>
        public bool matchTokens(int i1, VTDNav vn2, int i2)
        {
            return compareTokens(i1, vn2, i2)==0;
        }

        /// <summary>
        /// <em>New in 2.0</em>
	    /// This method compares two VTD tokens of VTDNav objects
	    /// The behavior of this method is like compare the strings corresponds
	    /// to i1 and i2
        /// </summary>
        /// <param name="i"></param>
        /// <param name="vn2"></param>
        /// <param name="i2"></param>
        /// <returns></returns>
        public int compareTokens(int i1, VTDNav vn2, int i2)
        {
            int t1, t2;
            int ch1, ch2;
            int endOffset1, endOffset2;
            long l;

            if (i1 == i2 && this == vn2)
                return 0;

            t1 = this.getTokenType(i1);
            t2 = vn2.getTokenType(i2);

            int offset1 = this.getTokenOffset(i1);
            int offset2 = vn2.getTokenOffset(i2);

            endOffset1 = this.getTokenLength(i1) + offset1;
            endOffset2 = vn2.getTokenLength(i2) + offset2;

            for (; offset1 < endOffset1 && offset2 < endOffset2; )
            {
                if (t1 == VTDNav.TOKEN_CHARACTER_DATA
                        || t1 == VTDNav.TOKEN_ATTR_VAL)
                {
                    l = this.getCharResolved(offset1);
                }
                else
                {
                    l = this.getChar(offset1);
                }
                ch1 = (int)l;
                offset1 += (int)(l >> 32);

                if (t2 == VTDNav.TOKEN_CHARACTER_DATA
                        || t2 == VTDNav.TOKEN_ATTR_VAL)
                {
                    l = vn2.getCharResolved(offset2);
                }
                else
                {
                    l = vn2.getChar(offset2);
                }
                ch2 = (int)l;
                offset2 += (int)(l >> 32);

                if (ch1 > ch2)
                    return 1;
                if (ch1 < ch2)
                    return -1;
            }

            if (offset1 == endOffset1
                    && offset2 < endOffset2)
                return -1;
            else if (offset1 < endOffset1
                    && offset2 == endOffset2)
                return 1;
            else
                return 0;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected internal int compareTokenString(int offset, int len, String s)
        {
            int i, l;
            long l1;
            //this.currentOffset = offset;
            int endOffset = offset + len;

            //       System.out.print("currentOffset :" + currentOffset);
            l = s.Length;
            //System.out.println(s);
            for (i = 0; i < l && offset < endOffset; i++)
            {
                l1 = getCharResolved(offset);
                int i1 = s[i];
                if (i1 < (int)l1)
                    return 1;
                if (i1 > (int)l1)
                    return -1;
                offset += (int)(l1 >> 32);
            }

            if (i == l && offset < endOffset)
                return 1;
            if (i < l && offset == endOffset)
                return -1;
            return 0;
        }
        /// <summary>
        /// <em>New in 2.0</em>
	    /// Compare the string against the token at the given index value. When a token
	    /// is an attribute name or starting tag, qualified name is what gets compared against
	    /// This method has to take care of the underlying encoding conversion
	    /// but it <em> doesn't </em> resolve entity reference in the underlying document
	    /// The behavior is the same as calling toRawString on index, then compare to s
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public int compareRawTokenString(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                (type == TOKEN_STARTING_TAG
                    || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                    ? getTokenLength(index) & 0xffff
                    : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareRawTokenString(getTokenOffset(index), len, s);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected internal int compareRawTokenString(int offset, int len, String s)
        {
            int i, l;
            long l1;
            //this.currentOffset = offset;
            int endOffset = offset + len;


            //       System.out.print("currentOffset :" + currentOffset);
            l = s.Length;
            //System.out.println(s);
            for (i = 0; i < l && offset < endOffset; i++)
            {
                l1 = getChar(offset);
                int i1 = s[i];
                if (i1 < (int)l1)
                    return 1;
                if (i1 > (int)l1)
                    return -1;
                offset += (int)(l1 >> 32);
            }

            if (i == l && offset < endOffset)
                return 1;
            if (i < l && offset == endOffset)
                return -1;
            return 0;
        }
        /// <summary>
        /// <em>New in 2.0</em>
	    /// Compare the string against the token at the given index value. When a token
	    /// is an attribute name or starting tag, qualified name is what gets matched against
	    /// This method has to take care of the underlying encoding conversion
	    /// as well as entity reference comparison
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public int compareTokenString(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                (type == TOKEN_STARTING_TAG
                    || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                    ? getTokenLength(index) & 0xffff
                    : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareTokenString(getTokenOffset(index), len, s);
        }

 
  
    }
}
