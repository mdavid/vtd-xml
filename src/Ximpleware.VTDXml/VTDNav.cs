/* 
* Copyright (C) 2002-2011 XimpleWare, info@ximpleware.com
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/
// added set
using System;
using System.Text;
using UTF8Char = com.ximpleware.parser.UTF8Char;
using com.ximpleware.parser;
namespace com.ximpleware
{
    /// <summary> 
    /// 
    /// </summary>
    /// <summary> VTD navigator class implementation</summary>
    public class VTDNav
    {
        /// <summary> Return the attribute count of the element at the cursor position.
        /// when ns is false, ns tokens are considered attributes;
        /// otherwise, ns tokens are not considered attributes
        /// </summary>
        /// <returns> int
        /// </returns>
        protected VTDNav() { }
        public int getAttrCount()
        {
            if (context[0] == -1)
                return 0;
            int count = 0;
            int index = getCurrentIndex() + 1;
            while (index < vtdSize)
            {
                int type = getTokenType(index);
                if (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_VAL || type == TOKEN_ATTR_NS)
                {
                    if (type == TOKEN_ATTR_NAME || (!ns && (type == TOKEN_ATTR_NS)))
                    {
                        count++;
                    }
                }
                else
                    break;
                index++;
            }
            return count;
        }

        static public int swap_bytes(int i)
        {
            return (((i & 0xff) << 24) |
                ((i & 0xff00) << 8) |
                ((i & 0xff0000) >> 8) |
                ((i & -0x01000000) >> 24) & 0xff);
        }

        private long getChar4OtherEncoding(int offset)
        {
            if (encoding <= FORMAT_WIN_1258)
            {
                int temp = decode(offset);
                if (temp == '\r')
                {
                    if (XMLDoc.byteAt(offset + 1) == '\n')
                    {
                        return '\n' | (2L << 32);
                    }
                    else
                    {
                        return '\n' | (1L << 32);
                    }
                }
                return temp | (1L << 32);
            }
            throw new NavException("Unknown Encoding");
        }

        /// <summary> This method decodes the underlying byte array into corresponding UCS2 char representation .
        /// It doesn't resolves built-in entity and character references.
        /// Length will never be zero
        /// Creation date: (11/21/03 6:26:17 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception is thrown if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD can be generated by another
        /// machine, e.g. from a load-balancer.
        /// </exception>
        private long getChar(int offset)
        {
            long temp = 0;

            switch (encoding)
            {

                case FORMAT_ASCII:  // ascii is compatible with UTF-8, the offset value is bytes
                    temp = XMLDoc.byteAt(offset);
                    if (temp == '\r')
                    {
                        if (XMLDoc.byteAt(offset + 1) == '\n')
                        {
                            return '\n' | (2L << 32);
                        }
                        else
                        {
                            return '\n' | (1L << 32);
                        }
                    }
                    return temp | (1L << 32);

                case FORMAT_ISO_8859_1:
                    temp = XMLDoc.byteAt(offset);
                    if (temp == '\r')
                    {
                        if (XMLDoc.byteAt(offset + 1) == '\n')
                        {
                            return '\n' | (2L << 32);
                        }
                        else
                        {
                            return '\n' | (1L << 32);
                        }
                    }
                    return temp | (1L << 32);

                case FORMAT_UTF8:
                    temp = XMLDoc.byteAt(offset);
                    if (temp <= 127)
                    {
                        if (temp == '\r')
                        {
                            if (XMLDoc.byteAt(offset + 1) == '\n')
                            {
                                return '\n' | (2L << 32);
                            }
                            else
                            {
                                return '\n' | (1L << 32);
                            }
                        }
                        //currentOffset++;
                        return temp | (1L << 32);
                    }
                    return handle_utf8(temp, offset);

                case FORMAT_UTF_16BE:
                    // implement UTF-16BE to UCS4 conversion

                    return handle_utf16be(offset);


                case FORMAT_UTF_16LE:

                    return handle_utf16le(offset);
                //System.out.println("UTF 16 LE unimplemented for now");
                //goto default;


                default:
                    return getChar4OtherEncoding(offset);
                //throw new NavException("Unknown Encoding");
            }
            /* the exact same copy of getChar except it operates on currentOffset2
            * this is needed to compare VTD tokens directly
            */

        }

        /// <summary> This method decodes the underlying byte array into corresponding UCS2 char representation .
        /// Also it resolves built-in entity and character references.
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception is thrown if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        private long getCharResolved(int offset)
        {
            int ch = 0;
            int val = 0;
            long inc = 2;
            long l = getChar(offset);

            ch = (int)l;

            if (ch != '&')
                return l;

            // let us handle references here
            offset++;
            ch = getCharUnit(offset);
            offset++;
            switch (ch)
            {

                case '#':

                    ch = getCharUnit(offset);

                    if (ch == 'x')
                    {
                        while (true)
                        {
                            offset++;
                            inc++;
                            ch = getCharUnit(offset);

                            if (ch >= '0' && ch <= '9')
                            {
                                val = (val << 4) + (ch - '0');
                            }
                            else if (ch >= 'a' && ch <= 'f')
                            {
                                val = (val << 4) + (ch - 'a' + 10);
                            }
                            else if (ch >= 'A' && ch <= 'F')
                            {
                                val = (val << 4) + (ch - 'A' + 10);
                            }
                            else if (ch == ';')
                            {
                                inc++;
                                break;
                            }
                            else
                                throw new NavException("Illegal char in a char reference");
                        }
                    }
                    else
                    {
                        while (true)
                        {
                            ch = getCharUnit(offset);
                            offset++;
                            inc++;
                            if (ch >= '0' && ch <= '9')
                            {
                                val = val * 10 + (ch - '0');
                            }
                            else if (ch == ';')
                            {
                                break;
                            }
                            else
                                throw new NavException("Illegal char in char reference");
                        }
                    }
                    break;


                case 'a':
                    ch = getCharUnit(offset);
                    if (ch == 'm')
                    {
                        if (getCharUnit(offset + 1) == 'p' && getCharUnit(offset + 2) == ';')
                        {
                            inc = 5;
                            val = '&';
                        }
                        else
                            throw new NavException("illegal builtin reference");
                    }
                    else if (ch == 'p')
                    {
                        if (getCharUnit(offset + 1) == 'o' && getCharUnit(offset + 2) == 's' && getCharUnit(offset + 3) == ';')
                        {
                            inc = 6;
                            val = '\'';
                        }
                        else
                            throw new NavException("illegal builtin reference");
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;


                case 'q':

                    if (getCharUnit(offset) == 'u'
                        && getCharUnit(offset + 1) == 'o'
                        && getCharUnit(offset + 2) == 't'
                        && getCharUnit(offset + 3) == ';')
                    {
                        inc = 6;
                        val = '\"';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;

                case 'l':
                    if (getCharUnit(offset) == 't'
                        && getCharUnit(offset + 1) == ';')
                    {
                        inc = 4;
                        val = '<';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;

                case 'g':
                    if (getCharUnit(offset) == 't' && getCharUnit(offset + 1) == ';')
                    {
                        inc = 4;
                        val = '>';
                    }
                    else
                        throw new NavException("illegal builtin reference");
                    break;


                default:
                    throw new NavException("Invalid entity char");

            }

            //currentOffset++;
            return val | (inc << 32);
        }


        public int getCurrentDepth()
        {
            return context[0];
        }
        /// <summary> Get the index value of the current element.
        /// Creation date: (11/16/03 6:40:25 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getCurrentIndex()
        {
            if (atTerminal)
                return LN;
            switch (context[0])
            {

                case -1: return 0;

                case 0: return rootIndex;

                default: return context[context[0]];

            }
            //return (context[0] == 0) ? rootIndex : context[context[0]];

        }
        protected internal int getCurrentIndex2()
        {
            switch (context[0])
            {

                case -1: return 0;

                case 0: return rootIndex;

                default: return context[context[0]];

            }
        }
        /// <summary> Get the starting offset and length of an element
        /// encoded in a long, upper 32 bit is length; lower 32 bit is offset
        /// Unit is in byte.
        /// Creation date: (3/15/04 1:47:55 PM)
        /// </summary>
        public long getElementFragment()
        {
            // a little scanning is needed
            // has next sibling case
            // if not
            int temp, so2, d, i;
            int depth = getCurrentDepth();
            //		 document length and offset returned if depth == -1
            if (depth == -1)
            {
                int ii = vtdBuffer.lower32At(0);
                if (ii == 0)
                    return ((long)docLen) << 32 | docOffset;
                else
                    return ((long)(docLen - 32)) | 32;
            }
            int so = getTokenOffset(getCurrentIndex2()) - 1;
            int length = 0;


            // for an element with next sibling
            if (toElement(NEXT_SIBLING))
            {

                temp = getCurrentIndex();
                // rewind 
                while (getTokenDepth(temp) < depth)
                {
                    temp--;
                }
                //temp++;
                so2 = getTokenOffset(temp) - 1;
                // look for the first '>'
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                length = so2 - so + 1;
                toElement(PREV_SIBLING);
                if (encoding <= FORMAT_WIN_1258)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }

            // for root element
            if (depth == 0)
            {
                temp = vtdBuffer.size_Renamed_Field - 1;
                bool b = false;
                so2 = 0;
                while (getTokenDepth(temp) == -1)
                {
                    temp--; // backward scan
                    b = true;
                }
                if (b == false)
                    so2 = (encoding < FORMAT_WIN_1258) ? (docOffset + docLen - 1) : ((docOffset + docLen) >> 1) - 1;
                else
                    so2 = getTokenOffset(temp + 1);
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                length = so2 - so + 1;
                if (encoding <= FORMAT_WIN_1258)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }
            // for a non-root element with no next sibling
            temp = getCurrentIndex() + 1;
            int size = vtdBuffer.size_Renamed_Field;
            // temp is not the last entry in VTD buffer
            if (temp < size - 1)
            {
                while (temp < size && getTokenDepth(temp) >= depth)
                {
                    temp++;
                }
                if (temp != size)
                {
                    d = depth - getTokenDepth(temp) + ((getTokenType(temp) == TOKEN_STARTING_TAG) ? 1 : 0);
                    so2 = getTokenOffset(temp) - 1;
                    i = 0;
                    // scan backward
                    while (i < d)
                    {
                        if (getCharUnit(so2) == '>')
                            i++;
                        so2--;
                    }
                    length = so2 - so + 2;
                    if (encoding <= FORMAT_WIN_1258)
                        return ((long)length) << 32 | so;
                    else
                        return ((long)length) << 33 | (so << 1);
                }
                /*
                int so2 = getTokenOffset(temp - 1) - 1;
                int d = depth - getTokenDepth(temp - 1);
                int i = 0;
                while (i < d) {
                if (getCharUnit(so2) == '>') {
                i++;
                }
                so2--;
                }
                length = so2 - so + 2;
                if (encoding < 3)
                return ((long) length) << 32 | so;
                else
                return ((long) length) << 33 | (so << 1);*/
            }
            // temp is the last entry
            // scan forward search for /> or </cc>
            so2 = (encoding <= FORMAT_WIN_1258) ? (docOffset + docLen - 1) : ((docOffset + docLen) >> 1) - 1;
            d = depth + 1;
            i = 0;
            while (i < d)
            {
                if (getCharUnit(so2) == '>')
                {
                    i++;
                }
                so2--;
            }

            length = so2 - so + 2;

            if (encoding <= FORMAT_WIN_1258)
                return ((long)length) << 32 | so;
            else
                return ((long)length) << 33 | (so << 1);


        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public ElementFragmentNs getElementFragmentNs()
        {
            if (this.ns == false)
                throw new NavException("getElementFragmentNS can only be called ");

            FastIntBuffer fib = new FastIntBuffer(3); // init size 8

            //fill the fib with integer 
            // first get the list of name space nodes 
            int[] ia = context;
            int d = ia[0]; // -1 for document node, 0 for root element;
            int c = getCurrentIndex2();


            int len = (c == 0 || c == rootIndex) ? 0 :
                (getTokenLength(c) & 0xffff); // get the length of qualified node

            // put the neighboring ATTR_NS nodes into the array
            // and record the total # of them	     
            int i = 0;
            int count = 0;
            if (d > 0)
            { // depth > 0 every node except document and root element
                int k = getCurrentIndex2() + 1;
                if (k < this.vtdSize)
                {
                    while (k < this.vtdSize)
                    {
                        int type = this.getTokenType(k);
                        if (type == VTDNav.TOKEN_ATTR_NAME || type == VTDNav.TOKEN_ATTR_NS)
                        {
                            if (type == VTDNav.TOKEN_ATTR_NS)
                            {
                                fib.append(k);
                                //System.out.println(" ns name ==>" + toString(k));
                            }
                        }
                        k += 2;
                        //type = this.getTokenType(k);
                    }
                }
                count = fib.size_Renamed_Field;
                d--;
                while (d >= 0)
                {
                    // then search for ns node in the vinicity of the ancestor nodes
                    if (d > 0)
                    {
                        // starting point
                        k = ia[d] + 1;
                    }
                    else
                    {
                        // starting point
                        k = this.rootIndex + 1;
                    }
                    if (k < this.vtdSize)
                    {
                        while (k < this.vtdSize)
                        {
                            int type = this.getTokenType(k);
                            if (type == VTDNav.TOKEN_ATTR_NAME || type == VTDNav.TOKEN_ATTR_NS)
                            {
                                bool unique = true;
                                if (type == VTDNav.TOKEN_ATTR_NS)
                                {
                                    for (int z = 0; z < fib.size_Renamed_Field; z++)
                                    {
                                        //System.out.println("fib size ==> "+fib.size_Renamed_Field);
                                        //if (fib.size_Renamed_Field == 4) ;
                                        if (matchTokens(fib.intAt(z), this, k))
                                        {
                                            unique = false;
                                            break;
                                        }

                                    }
                                    if (unique)
                                        fib.append(k);
                                }
                            }
                            k += 2;
                            //type = this.getTokenType(k);
                        }
                    }
                    d--;
                }
                // System.out.println("count ===> "+count);
                // then restore the name space node by shifting the array
                int newSz = fib.size_Renamed_Field - count;
                for (i = 0; i < newSz; i++)
                {
                    fib.modifyEntry(i, fib.intAt(i + count));
                }
                fib.size_Renamed_Field = newSz;
            }

            long l = getElementFragment();
            return new ElementFragmentNs(this, l, fib, len);
        }
        /// <summary> Get the encoding of the XML document.
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getEncoding()
        {
            return encoding;
        }
        /// <summary> Get the maximum nesting depth of the XML document (>0).
        /// max depth is nestingLevel -1
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getNestingLevel()
        {
            return nestingLevel;
        }
        /// <summary> Get root index value , which is the index val of document element</summary>
        /// <returns> int
        /// </returns>
        public int getRootIndex()
        {
            return rootIndex;
        }
        /// <summary> This method returns of the token index of the type character data or CDATA.
        /// Notice that it is intended to support data orient XML (not mixed-content XML).
        /// return the index of the text token, or -1 if none exists.
        /// </summary>
        /// <returns> int
        /// </returns>
        public int getText()
        {
            if (context[0] == -1)
                return -1;
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            int depth = getCurrentDepth();
            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;

            while (true)
            {
                if (type == TOKEN_CHARACTER_DATA || type == TOKEN_CDATA_VAL)
                {
                    if (depth == getTokenDepth(index))
                        return index;
                    else
                        return -1;
                }
                else if (type == TOKEN_ATTR_NS || type == TOKEN_ATTR_NAME)
                {
                    index += 2; // assuming a single token for attr val
                }
                else if (type == TOKEN_PI_NAME || type == TOKEN_PI_VAL || type == TOKEN_COMMENT)
                {
                    if (depth == getTokenDepth(index))
                    {
                        index += 1;
                    }
                    else
                        return -1;
                }
                else
                    return -1;
                if (index >= vtdSize)
                    break;
                type = getTokenType(index);
            }
            return -1;
        }
        /// <summary> Get total number of VTD tokens for the current XML document.</summary>
        /// <returns> int
        /// </returns>
        public int getTokenCount()
        {
            return vtdSize;
        }
        /// <summary>Get the XML document </summary>
        /// <returns> IByteBuffer
        /// </returns>
        public IByteBuffer getXML()
        {
            return XMLDoc;
        }
        private long handle_utf8(long temp, int offset)
        {
            int a, d, c;
            long val;

            switch (UTF8Char.byteCount((int)temp & 0xff))
            {
                case 2:
                    c = 0x1f;
                    d = 6;
                    a = 1;
                    break;

                case 3:
                    c = 0x0f;
                    d = 12;
                    a = 2;
                    break;

                case 4:
                    c = 0x07;
                    d = 18;
                    a = 3;
                    break;

                case 5:
                    c = 0x03;
                    d = 24;
                    a = 4;
                    break;

                case 6:
                    c = 0x01;
                    d = 30;
                    a = 5;
                    break;

                default:
                    throw new NavException("UTF 8 encoding error: should never happen");

            }

            val = (temp & c) << d;
            int i = a - 1;
            while (i >= 0)
            {
                temp = XMLDoc.byteAt(offset + a - i);
                if ((temp & 0xc0) != 0x80)
                    throw new NavException("UTF 8 encoding error: should never happen");
                val = val | ((temp & 0x3f) << ((i << 2) + (i << 1)));
                i--;
            }
            //currentOffset += a + 1;
            return val | (((long)(a + 1)) << 32);
        }

        private long handle_utf16be(int offset)
        {
            int val, temp = ((XMLDoc.byteAt(offset << 1)) << 8) | (XMLDoc.byteAt((offset << 1) + 1));
            if ((temp < 0xd800) || (temp > 0xdfff))
            {
                // not a high surrogate
                if (temp == '\r')
                {
                    if (XMLDoc.byteAt((offset << 1) + 3) == '\n' && XMLDoc.byteAt((offset << 1) + 2) == 0)
                    {
                        return '\n' | (2L << 32);
                    }
                    else
                    {
                        return '\n' | (1L << 32);
                    }
                }
                return temp | (1L << 32);
            }
            else
            {
                if (temp < 0xd800 || temp > 0xdbff)
                    throw new NavException("UTF 16 BE encoding error: should never happen");
                val = temp;
                temp = ((XMLDoc.byteAt((offset << 1) + 2)) << 8) | (XMLDoc.byteAt((offset << 1) + 3));
                if (temp < 0xdc00 || temp > 0xdfff)
                {
                    // has to be a low surrogate here
                    throw new NavException("UTF 16 BE encoding error: should never happen");
                }
                val = ((temp - 0xd800) << 10) + (val - 0xdc00) + 0x10000;
                return val | (2L << 32);
            }
            //goto case FORMAT_UTF_16LE;
        }
        private long handle_utf16le(int offset)
        {
            // implement UTF-16LE to UCS4 conversion
            int val, temp = (XMLDoc.byteAt((offset << 1) + 1)) << 8 | (XMLDoc.byteAt(offset << 1));
            if (temp < 0xdc00 || temp > 0xdfff)
            {
                // check for low surrogate
                if (temp == '\r')
                {
                    if (XMLDoc.byteAt((offset << 1) + 2) == '\n' && XMLDoc.byteAt((offset << 1) + 3) == 0)
                    {
                        return '\n' | (2L << 32);
                    }
                    else
                    {
                        return '\n' | (1L << 32);
                    }
                }
                return temp | (1L << 32);
            }
            else
            {
                if (temp < 0xd800 || temp > 0xdbff)
                    throw new NavException("UTF 16 LE encoding error: should never happen");
                val = temp;
                temp = (XMLDoc.byteAt((offset << 1) + 3)) << 8 | (XMLDoc.byteAt((offset << 1) + 2));
                if (temp < 0xdc00 || temp > 0xdfff)
                {
                    // has to be high surrogate
                    throw new NavException("UTF 16 LE encoding error: should never happen");
                }
                val = ((temp - 0xd800) << 10) + (val - 0xdc00) + 0x10000;
                return val | (2L << 32);
            }
        }
        //UPGRADE_NOTE: Respective javadoc comments were merged.  It should be changed in order to comply with .NET documentation conventions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1199'"
        /// <summary> Get the value of atTerminal
        /// This function only gets called in XPath eval
        /// </summary>
        /// <returns>
        /// </returns>
        /// <summary> Set the value of atTerminal
        /// This function only gets called in XPath eval
        /// when a step calls for @* or child::text()
        /// </summary>
        /// <param name="b">
        /// </param>
        protected internal bool AtTerminal
        {
            get
            {
                return atTerminal;
            }

            set
            {
                atTerminal = value;
            }

        }
        // Navigation directions
        public const int ROOT = 0;
        public const int PARENT = 1;
        public const int FIRST_CHILD = 2;
        public const int LAST_CHILD = 3;
        public const int NEXT_SIBLING = 4;
        public const int PREV_SIBLING = 5;

        // Navigation directions
        public const int R = 0;
        public const int P = 1;
        public const int FC = 2;
        public const int LC = 3;
        public const int NS = 4;
        public const int PS = 5;

        // token type definitions
        public const int TOKEN_STARTING_TAG = 0;
        public const int TOKEN_ENDING_TAG = 1;
        public const int TOKEN_ATTR_NAME = 2;
        public const int TOKEN_ATTR_NS = 3;
        public const int TOKEN_ATTR_VAL = 4;
        public const int TOKEN_CHARACTER_DATA = 5;
        public const int TOKEN_COMMENT = 6;
        public const int TOKEN_PI_NAME = 7;
        public const int TOKEN_PI_VAL = 8;
        public const int TOKEN_DEC_ATTR_NAME = 9;
        public const int TOKEN_DEC_ATTR_VAL = 10;
        public const int TOKEN_CDATA_VAL = 11;
        public const int TOKEN_DTD_VAL = 12;
        public const int TOKEN_DOCUMENT = 13;

        // encoding format definition here

        public const int FORMAT_ASCII = 0;
        public const int FORMAT_ISO_8859_1 = 1;
        public const int FORMAT_UTF8 = 2;
        public const int FORMAT_ISO_8859_2 = 3;
        public const int FORMAT_ISO_8859_3 = 4;
        public const int FORMAT_ISO_8859_4 = 5;
        public const int FORMAT_ISO_8859_5 = 6;
        public const int FORMAT_ISO_8859_6 = 7;
        public const int FORMAT_ISO_8859_7 = 8;
        public const int FORMAT_ISO_8859_8 = 9;
        public const int FORMAT_ISO_8859_9 = 10;
        public const int FORMAT_ISO_8859_10 = 11;
        public const int FORMAT_ISO_8859_11 = 12;
        public const int FORMAT_ISO_8859_12 = 13;
        public const int FORMAT_ISO_8859_13 = 14;
        public const int FORMAT_ISO_8859_14 = 15;
        public const int FORMAT_ISO_8859_15 = 16;
        public const int FORMAT_ISO_8859_16 = 17;

        public const int FORMAT_WIN_1250 = 18;
        public const int FORMAT_WIN_1251 = 19;
        public const int FORMAT_WIN_1252 = 20;
        public const int FORMAT_WIN_1253 = 21;
        public const int FORMAT_WIN_1254 = 22;
        public const int FORMAT_WIN_1255 = 23;
        public const int FORMAT_WIN_1256 = 24;
        public const int FORMAT_WIN_1257 = 25;
        public const int FORMAT_WIN_1258 = 26;


        public const int FORMAT_UTF_16LE = 64;
        public const int FORMAT_UTF_16BE = 63;




        // masks for obtaining various fields from a VTD token 
        protected internal const long MASK_TOKEN_FULL_LEN = 0x000fffff00000000;
        protected const long MASK_TOKEN_PRE_LEN = 0x000ff80000000000;
        protected const long MASK_TOKEN_QN_LEN = 0x000007ff00000000;
        internal static long MASK_TOKEN_OFFSET = 0x000000003fffffff;
        //UPGRADE_TODO: Literal detected as an unsigned long can generate compilation errors. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1175'"
        protected const long MASK_TOKEN_TYPE = unchecked((long)0xf000000000000000);
        //UPGRADE_TODO: Literal detected as an unsigned long can generate compilation errors. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1175'"
        protected const long MASK_TOKEN_DEPTH = 0x0ff0000000000000L;

        // tri-state variable for namespace lookup
        protected const long MASK_TOKEN_NS_MARK = 0x00000000c0000000L;
        protected short maxLCDepthPlusOne = 4;
        protected internal int rootIndex; // where the root element is at
        protected internal int nestingLevel;
        protected internal int[] context; // main navigation tracker aka context object
        protected internal bool atTerminal; // this variable is to make vn compatible with
        // xpath's data model


        // location cache part
        protected internal int l2upper;
        protected internal int l2lower;
        protected internal int l3upper;
        protected internal int l3lower;
        protected internal int l2index;
        protected internal int l3index;
        protected internal int l1index;

        // containers
        protected internal FastLongBuffer vtdBuffer;
        protected internal FastLongBuffer l1Buffer;
        protected internal FastLongBuffer l2Buffer;
        protected internal FastIntBuffer l3Buffer;
        protected internal IByteBuffer XMLDoc;

        //private int recentNS; // most recently visited NS node, experiment for now
        // Hierarchical representation is an array of integers addressing elements tokens 
        protected ContextBuffer contextStack;
        protected internal ContextBuffer contextStack2; // this is reserved for XPath

        protected internal int LN; // record txt and attrbute for XPath eval purposes
        // the document encoding	     
        protected internal int encoding;
        // for string to token comparison
        //protected internal int currentOffset;
        //protected internal int currentOffset2;

        // whether the navigation is namespace enabled or not. 
        protected internal bool ns;

        // intermediate buffer for push and pop purposes  
        protected internal int[] stackTemp;
        protected internal int docOffset;
        // length of the document
        protected internal int docLen;
        protected internal int vtdSize; //vtd record count

        protected internal String name;
        protected internal int nameIndex;

        protected internal String localName;
        protected internal int localNameIndex;
        protected internal FastIntBuffer fib;//for store string value 
        protected internal bool shallowDepth;

        /// <summary> Initialize the VTD navigation object.</summary>
        /// <param name="RootIndex">int
        /// </param>
        /// <param name="maxDepth">int
        /// </param>
        /// <param name="encoding">int
        /// </param>
        /// <param name="NS"> boolean
        /// </param>
        /// <param name="x">byte[]
        /// </param>
        /// <param name="vtd">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l1">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l2">com.ximpleware.ILongBuffer
        /// </param>
        /// <param name="l3">com.ximpleware.IIntBuffer
        /// </param>
        /// <param name="so">int  starting offset of the document(in byte)
        /// </param>
        /// <param name="length">int length of the document (in byte)
        /// </param>
        protected internal VTDNav(int RootIndex, int enc, bool NS, int depth, IByteBuffer x, FastLongBuffer vtd, FastLongBuffer l1, FastLongBuffer l2, FastIntBuffer l3, int so, int length)
        {
            // initialize all buffers
            if (l1 == null || l2 == null || l3 == null || vtd == null || x == null || depth < 0 || RootIndex < 0 || so < 0 || length < 0)
            {
                throw new System.ArgumentException();
            }

            l1Buffer = l1;
            l2Buffer = l2;
            l3Buffer = l3;
            vtdBuffer = vtd;
            XMLDoc = x;

            encoding = enc;
            //System.out.println("encoding " + encoding);
            rootIndex = RootIndex;
            nestingLevel = depth + 1;
            ns = NS; // namespace aware or not
            if (ns == false)
                MASK_TOKEN_OFFSET = 0x000000007fffffff;
            // this allows xml size to be 2GB 
            // if there is no namespace
            else
                MASK_TOKEN_OFFSET = 0x000000003fffffff;


            atTerminal = false; //this variable will only change value during XPath eval

            // initialize the context object
            context = new int[nestingLevel];
            //depth value is the first entry in the context because root is singular.
            context[0] = 0;
            //set the value to zero
            for (int i = 1; i < nestingLevel; i++)
            {
                context[i] = -1;
            }
            // currentOffset = 0;
            //contextStack = new ContextBuffer(1024, nestingLevel + 7);
            contextStack = new ContextBuffer(10, nestingLevel + 9);
            contextStack2 = new ContextBuffer(10, nestingLevel + 9);
            stackTemp = new int[nestingLevel + 9];

            // initial state of LC variables
            l1index = l2index = l3index = -1;
            l2lower = l3lower = -1;
            l2upper = l3upper = -1;
            docOffset = so;
            docLen = length;
            //System.out.println("offset " + offset + "  length " + length);
            //printL2Buffer();
            vtdSize = vtd.size_Renamed_Field;
            name = null;
            nameIndex = -1;
            localName = null;
            localNameIndex = -1;
            fib = new FastIntBuffer(5);
            shallowDepth = true;
            //recentNS = -1;
        }
        /// <summary> This method print out the current state info of the navigation object.
        /// It is for debugging purpose.
        /// </summary>
        public void dumpContext()
        {
            for (int i = 0; i < context.Length; i++)
            {
                System.Console.Out.WriteLine("context[" + i + "] ==>" + context[i]);
            }
            try
            {
                System.Console.Out.WriteLine("element name -->" + toRawString(getCurrentIndex()));
            }
            catch (NavException e)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'Throwable.toString' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                System.Console.Out.WriteLine("toString exception condition occurred " + e);
            }
        }
        /// <summary>
        /// dump the XML text into a stream
        /// </summary>
        /// <param name="os">output stream</param>
        public void dumpXML(System.IO.Stream os)
        {
            os.Write(this.XMLDoc.getBytes(), this.docOffset, this.docLen);
        }

        /// <summary>
        /// Dump the XML text into a file with the given fileName
        /// </summary>
        /// <param name="fileName"></param>
        public void dumpXML(String fileName)
        {
            System.IO.FileStream fos = new System.IO.FileStream(fileName, System.IO.FileMode.Create);
            try
            {
                dumpXML(fos);
            }
            finally
            {
                fos.Close();
            }
        }

        /// <summary> Get the token index of the attribute value given an attribute name.     </summary>
        /// <returns> int  (-1 if no such attribute name exists)
        /// </returns>
        /// <param name="an">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if an is null
        /// </exception>
        public int getAttrVal(System.String an)
        {
            //int size = vtdBuffer.size_Renamed_Field;
            if (context[0] == -1)
                return -1;
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;

            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;
            if (ns == false)
            {
                while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                {
                    if (matchRawTokenString(index, an))
                    {
                        // ns node visible only ns is disabled
                        return index + 1;
                    }
                    index += 2;
                    if (index >= vtdSize)
                        break;
                    type = getTokenType(index);
                }
            }
            else
            {
                while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                {
                    if (type == TOKEN_ATTR_NAME && matchRawTokenString(index, an))
                    {
                        // ns node visible only ns is disabled
                        return index + 1;
                    }
                    index += 2;
                    if (index >= vtdSize)
                        break;
                    type = getTokenType(index);
                }
            }
            return -1;
        }
        /// <summary> Get the token index of the attribute value of given URL and local name.
        /// If ns is not enabled, the lookup will return -1, indicating a no-found.
        /// Also namespace nodes are invisible using this method.
        /// One can't use * to indicate any name space because * is ambiguous!!
        /// </summary>
        /// <returns> int (-1 if no matching attribute found)
        /// </returns>
        /// <param name="URL">String  (Name space URL)
        /// </param>
        /// <param name="ln">String   (local name)
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if s is null
        /// </exception>
        public int getAttrValNS(System.String URL, System.String ln)
        {
            if (ns == false)
                return -1;
            if (URL != null && URL.Length == 0)
                URL = null;
            if (URL == null)
                return getAttrVal(ln);
            int size = vtdBuffer.size_Renamed_Field;
            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            // point to the token next to the element tag
            int type;
            if (index < vtdSize)
                type = getTokenType(index);
            else
                return -1;
            while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
            {
                int i = getTokenLength(index);
                int offset = getTokenOffset(index);
                int preLen = (i >> 16) & 0xffff;
                int fullLen = i & 0xffff;
                if (preLen != 0 && matchRawTokenString(offset + preLen + 1, fullLen - preLen - 1, ln) && resolveNS(URL, offset, preLen))
                {
                    return index + 1;
                }
                else if (preLen == 3
                    && matchRawTokenString(offset, 3, "xml")
                    && URL.Equals("http://www.w3.org/XML/1998/namespace"))
                {
                    // prefix matches "xml"
                    return index + 1;
                }
                index += 2;
                if (index >= vtdSize)
                    break;
                type = getTokenType(index);
            }
            return -1;
        }

        private int decode(int offset)
        {
            byte ch = XMLDoc.byteAt(offset);
            switch (encoding)
            {
                case FORMAT_ISO_8859_2:
                    return ISO8859_2.decode(ch);
                case FORMAT_ISO_8859_3:
                    return ISO8859_3.decode(ch);
                case FORMAT_ISO_8859_4:
                    return ISO8859_4.decode(ch);
                case FORMAT_ISO_8859_5:
                    return ISO8859_5.decode(ch);
                case FORMAT_ISO_8859_6:
                    return ISO8859_6.decode(ch);
                case FORMAT_ISO_8859_7:
                    return ISO8859_7.decode(ch);
                case FORMAT_ISO_8859_8:
                    return ISO8859_8.decode(ch);
                case FORMAT_ISO_8859_9:
                    return ISO8859_9.decode(ch);
                case FORMAT_ISO_8859_10:
                    return ISO8859_10.decode(ch);
                case FORMAT_ISO_8859_11:
                    return ISO8859_11.decode(ch);
                case FORMAT_ISO_8859_13:
                    return ISO8859_13.decode(ch);
                case FORMAT_ISO_8859_14:
                    return ISO8859_14.decode(ch);
                case FORMAT_ISO_8859_15:
                    return ISO8859_15.decode(ch);
                case FORMAT_WIN_1250:
                    return WIN1250.decode(ch);
                case FORMAT_WIN_1251:
                    return WIN1251.decode(ch);
                case FORMAT_WIN_1252:
                    return WIN1252.decode(ch);
                case FORMAT_WIN_1253:
                    return WIN1253.decode(ch);
                case FORMAT_WIN_1254:
                    return WIN1254.decode(ch);
                case FORMAT_WIN_1255:
                    return WIN1255.decode(ch);
                case FORMAT_WIN_1256:
                    return WIN1256.decode(ch);
                case FORMAT_WIN_1257:
                    return WIN1257.decode(ch);
                default:
                    return WIN1258.decode(ch);
            }
        }
        /// <summary> Get the next char unit which gets decoded automatically</summary>
        /// <returns> int
        /// </returns>
        private int getCharUnit(int offset)
        {
            return (encoding <= 2)
                ? XMLDoc.byteAt(offset)
                : (encoding <= FORMAT_WIN_1258)
            ? decode(offset) : ((encoding == FORMAT_UTF_16BE)
            ? (XMLDoc.byteAt(offset << 1)
            << 8 | XMLDoc.byteAt((offset << 1) + 1)) :
            (XMLDoc.byteAt((offset << 1) + 1)
            << 8 | XMLDoc.byteAt(offset << 1)));
        }
        /// <summary> Get the depth value of a token (>=0).</summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        public int getTokenDepth(int index)
        {
            //int i = (int) vtdBuffer.longAt(index);           
            //i = ((i & 0x0f) << 4) | ((i & 0xf000) >> 12); 
            int i = (int)((vtdBuffer.longAt(index) & MASK_TOKEN_DEPTH) >> 52);

            if (i != 255)
                return i;
            return -1;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public long getOffsetAfterHead()
        {

            int i = getCurrentIndex();
            if (getTokenType(i) != VTDNav.TOKEN_STARTING_TAG)
            {
                return -1;
            }
            int j = i + 1;
            while (j < vtdSize && (getTokenType(j) == VTDNav.TOKEN_ATTR_NAME
                    || getTokenType(j) == VTDNav.TOKEN_ATTR_NS))
            {
                j += 2;
            }

            int enc = encoding;
            int offset; // this is character offset
            if (i + 1 == j)
            {
                offset = getTokenOffset(i) + ((ns == false) ? getTokenLength(i) : (getTokenLength(i) & 0xff));
            }
            else
            {
                offset = getTokenOffset(j - 1) + ((ns == false) ? getTokenLength(j - 1) : (getTokenLength(j + 1) & 0xff)) + 1;
            }

            while (getCharUnit(offset) != '>')
            {
                offset++;
            }
            
            if (getCharUnit(offset - 1) == '/')
                return (-1L <<32) | (long)offset;
            else
                return offset + 1;
            
        }

        /// <summary> Get the token length at the given index value
        /// please refer to VTD spec for more details
        /// Length is in terms of the UTF char unit
        /// For prefixed tokens, it is the qualified name length.
        /// When ns is not enabled, return the full name length for attribute name and element name
        /// When ns is enabled, return an int with upper 16 bit for prefix length, lower 16 bit for qname length 
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        public int getTokenLength(int index)
        {
            int type = getTokenType(index);
            int depth;
            //int val;
            int len = 0, j, temp;
            long l;

            switch (type)
            {

                case TOKEN_ATTR_NAME:
                case TOKEN_ATTR_NS:
                case TOKEN_STARTING_TAG:
                    l = vtdBuffer.longAt(index);
                    j = swap_bytes((int)l);
                    //return (this.ns == false)
                    //    ? j & 0xfffff
                    //    : ((j & 0xff800) << 5) | (j & 0x7ff);

                    return (ns == false) ? (int)((l & MASK_TOKEN_QN_LEN) >> 32) : ((int)((l & MASK_TOKEN_QN_LEN) >> 32) | ((int)((l & MASK_TOKEN_PRE_LEN) >> 32) << 5));

                case TOKEN_CHARACTER_DATA:
                case TOKEN_CDATA_VAL:
                case TOKEN_COMMENT:  // make sure this is total length
                    depth = getTokenDepth(index);
                    do
                    {
                        len = len + (int)((vtdBuffer.longAt(index) & MASK_TOKEN_FULL_LEN) >> 32);
                        temp = getTokenOffset(index) + (int)((vtdBuffer.longAt(index) & MASK_TOKEN_FULL_LEN) >> 32);
                        //len = len + (swap_bytes((int)vtdBuffer.longAt(index)) & 0xfffff);
                        index++;
                    }
                    while (index < vtdSize && depth == getTokenDepth(index) && type == getTokenType(index)
                         && temp == getTokenOffset(index));
                    //if (int k=0)
                    return len;

                default:
                    return (int)((vtdBuffer.longAt(index) & MASK_TOKEN_FULL_LEN) >> 32);
                //return swap_bytes((int)vtdBuffer.longAt(index)) & 0xfffff;


            }
            /*if (encoding<3)
            return val;
            else
            return val<<1;*/
        }
        /// <summary> Get the starting offset of the token at the given index.</summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="">
        /// </exception>
        public int getTokenOffset(int index)
        {
            //return (context[0] != 0)
            //    ? (int) (vtdBuffer.longAt(context[context[0]]) & MASK_TOKEN_OFFSET)
            //    : (int) (vtdBuffer.longAt(rootIndex) & MASK_TOKEN_OFFSET);
            return (int)(vtdBuffer.longAt(index) & MASK_TOKEN_OFFSET);
            //return swap_bytes((int) ((vtdBuffer.longAt(index) & MASK_TOKEN_OFFSET)>>32));
        }
        /// <summary> Get the token type of the token at the given index value.
        /// Creation date: (11/16/03 6:41:51 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="">
        /// </exception>
        public int getTokenType(int index)
        {
            return (int)((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf;
            //return ((int)vtdBuffer.longAt(index) & 0xf0) >> 4;
        }
        /// <summary> Test whether current element has an attribute with the matching name.
        /// "*" will match any attribute name, therefore is a test whether there is any attribute at all
        /// if namespace is disabled, this function will not distinguish between ns declaration and attribute 
        /// otherwise, ns tokens are invisible
        /// Creation date: (11/16/03 5:50:26 PM)
        /// </summary>
        /// <returns> boolean (true if such an attribute exists)
        /// </returns>
        /// <param name="an">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD etc can be generated by another
        /// machine from a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if an is null
        /// </exception>
        public bool hasAttr(System.String an)
        {
            if (context[0] == -1)
                return false;
            int size = vtdBuffer.size_Renamed_Field;

            int index = (context[0] != 0) ? context[context[0]] + 1 : rootIndex + 1;
            if (index >= size)
                return false;
            int type = getTokenType(index);
            if (ns == false)
            {
                if (an.Equals("*"))
                {
                    if (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                        return true;
                    else
                        return false;
                }
                else
                {
                    while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                    {
                        // ns tokens becomes visible
                        if (matchRawTokenString(index, an))
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
            }
            else
            {
                if (an.Equals("*"))
                {
                    while (index < size && (getTokenType(index) == TOKEN_ATTR_NAME || getTokenType(index) == TOKEN_ATTR_NS))
                    {
                        if (type == TOKEN_ATTR_NAME)
                            // TOKEN_ATTR_NS is invisible when ns == true
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
                else
                {
                    while (index < size && (type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                    {
                        if (type == TOKEN_ATTR_NAME && matchRawTokenString(index, an))
                            return true;
                        index += 2;
                        type = getTokenType(index);
                    }
                    return false;
                }
            }
        }
        /// <summary> Test whether the current element has an attribute with 
        /// matching namespace URL and localname.
        /// If ns is false, return false immediately
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">String (namespace URL)
        /// </param>
        /// <param name="ln">String  (localname )
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// </exception>
        public bool hasAttrNS(System.String URL, System.String ln)
        {
            return (getAttrValNS(URL, ln) != -1);
        }
        /// <summary> Test the token type, to see if it is a starting tag.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        protected internal bool isElement(int index)
        {
            return (((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf) == TOKEN_STARTING_TAG;
            //return (((((int)vtdBuffer.longAt(index)) & 0xf0) >> 4) == TOKEN_STARTING_TAG);
        }

        /// <summary> Test the token type, to see if it is a starting tag 
        /// or document token (introduced in 1.0).
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        protected internal bool isElementOrDocument(int index)
        {
            long i = (((vtdBuffer.longAt(index) & MASK_TOKEN_TYPE) >> 60) & 0xf);
            //int i = ((((int)vtdBuffer.longAt(index) & 0xf0) >> 4));

            return (i == TOKEN_STARTING_TAG || i == TOKEN_DOCUMENT);
        }
        /// <summary> Test whether ch is a white space character or not.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="ch">int
        /// </param>
        private bool isWS(int ch)
        {
            return (ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r');
        }

        /// <summary> This function is called by selectElement_P in autoPilot</summary>
        /// <param name="en">element Name
        /// </param>
        /// <param name="a">context of current position
        /// </param>
        /// <param name="special">whether the test type is node()
        /// </param>
        /// <returns> 
        /// </returns>
        /// <throws>  NavException </throws>
        protected internal virtual bool iterate_preceding(System.String en, int[] a, bool special)
        {
            int index = getCurrentIndex() - 1;
            int t, d;
            //int depth = getTokenDepth(index);
            //int size = vtdBuffer.size_Renamed_Field;
            while (index > 0)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    context[0] = depth;
                    //context[depth]=index;
                    if (depth > 0)
                    {
                        context[depth] = index;
                        t = index - 1;
                        for (int i = depth - 1; i > 0; i--)
                        {
                            if (context[i] > index || context[i] == -1)
                            {
                                while (t > 0)
                                {
                                    d = getTokenDepth(t);
                                    if (d == i && isElement(t))
                                    {
                                        context[i] = t;
                                        break;
                                    }
                                    t--;
                                }
                            }
                            else
                                break;
                        }
                    }
                    //dumpContext();
                    if (index != a[depth] && (special || matchElement(en)))
                    {
                        if (depth < maxLCDepthPlusOne)
                            resolveLC();
                        return true;
                    }
                }
                index--;
            }
            return false;
        }
        /// <summary> This function is called by selectElementNS_P in autoPilot</summary>
        /// <param name="URL">
        /// </param>
        /// <param name="ln">
        /// </param>
        /// <returns>
        /// </returns>
        /// <throws>  NavException </throws>
        protected internal virtual bool iterate_precedingNS(System.String URL, System.String ln, int[] a)
        {
            int index = getCurrentIndex() - 1;
            int t, d;
            //int depth = getTokenDepth(index);
            //int size = vtdBuffer.size_Renamed_Field;
            while (index > 0)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    context[0] = depth;
                    //context[depth]=index;
                    if (depth > 0)
                    {
                        context[depth] = index;
                        t = index - 1;
                        for (int i = depth - 1; i > 0; i--)
                        {
                            if (context[i] > index || context[i] == -1)
                            {
                                while (t > 0)
                                {
                                    d = getTokenDepth(t);
                                    if (d == i && isElement(t))
                                    {
                                        context[i] = t;
                                        break;
                                    }
                                    t--;
                                }
                            }
                            else
                                break;
                        }
                    }
                    //dumpContext();
                    if (index != a[depth] && matchElementNS(URL, ln))
                    {
                        if (depth < maxLCDepthPlusOne)
                            resolveLC();
                        return true;
                    }
                }
                index--;
            }
            return false;
        }
        /// <summary> This function is called by selectElement_F in autoPilot
        /// 
        /// </summary>
        /// <param name="en">ElementName
        /// </param>
        /// <param name="special">whether it is a node()
        /// </param>
        /// <returns>
        /// </returns>
        /// <throws>  NavException </throws>

        protected internal virtual bool  iterate_following(System.String en, bool special)
        {
            int index = getCurrentIndex() + 1;
            //int size = vtdBuffer.size_Renamed_Field;
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    context[0] = depth;
                    if (depth > 0)
                        context[depth] = index;
                    if (special || matchElement(en))
                    {
                        if (depth < maxLCDepthPlusOne)
                            resolveLC();
                        return true;
                    }
                }
                index++;
            }
            return false;
        }

        /// <summary> This function is called by selectElementNS_F in autoPilot</summary>
        /// <param name="URL">
        /// </param>
        /// <param name="ln">
        /// </param>
        /// <returns>
        /// </returns>
        /// <throws>  NavException </throws>
        protected internal virtual bool iterate_followingNS(System.String URL, System.String ln)
        {
            int index = getCurrentIndex() + 1;
            //int size = vtdBuffer.size_Renamed_Field;
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    context[0] = depth;
                    if (depth > 0)
                        context[depth] = index;
                    if (matchElementNS(URL, ln))
                    {
                        if (depth < maxLCDepthPlusOne)
                            resolveLC();
                        return true;
                    }
                }
                index++;
            }
            return false;
        }
        /// <summary> This method is similar to getElementByName in DOM except it doesn't
        /// return the nodeset, instead it iterates over those nodes. Notice that this method
        /// is called by the "iterate" method in the Autopilot class.
        /// "*" will match any element
        /// Creation date: (12/2/03 2:31:20 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="dp">int    (The depth of the starting position before iterating)
        /// </param>
        /// <param name="en">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception is signaled if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because VTD records can be generated by another
        /// machine from a load-balancer.
        /// null element name allowed represent node()in XPath;
        /// </exception>
        protected internal virtual bool iterate(int dp, System.String en, bool special)
        {
            // the navigation doesn't rely on LC
            // get the current depth
            int index = getCurrentIndex() + 1;
            //int size = vtdBuffer.size_Renamed_Field;
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    if (depth > dp)
                    {
                        context[0] = depth;
                        if (depth > 0)
                            context[depth] = index;
                        if (special || matchElement(en))
                        {
                            if (dp < maxLCDepthPlusOne)
                                resolveLC();
                            return true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                index++;
            }
            return false;
        }
        /// <summary> This method is similar to getElementByName in DOM except it doesn't
        /// return the nodeset, instead it iterates over those nodes .
        /// When URL is "*" it will match any namespace
        /// if ns is false, return false immediately
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="dp">int    (The depth of the starting position before iterating)
        /// </param>
        /// <param name="URL"> String
        /// </param>
        /// <param name="ln"> String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because VTD records can be generated by another
        /// machine from a load-balancer..
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// example
        /// 
        /// int depth = nv.getCurrentDepth()
        /// while(iterateNS(depth, "www.url.com","node_name")){
        /// push(); // store the current position
        /// //move position safely
        /// pop();  // load the position
        /// }
        /// </exception>
        protected internal virtual bool iterateNS(int dp, System.String URL, System.String ln)
        {
            if (ns == false)
                return false;

            int index = getCurrentIndex() + 1;
            while (index < vtdSize)
            {
                if (isElementOrDocument(index))
                {
                    int depth = getTokenDepth(index);
                    if (depth > dp)
                    {
                        context[0] = depth;
                        if (depth > 0)
                            context[depth] = index;
                        if (matchElementNS(URL, ln))
                        {
                            if (dp < maxLCDepthPlusOne)
                                resolveLC();
                            return true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                index++;
            }
            return false;
        }

        /// <summary> Test if the current element matches the given name.
        /// Creation date: (11/26/03 2:09:43 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="en">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">If the underlying raw char representation has errors.
        /// </exception>
        /// <exception cref="IllegalArguementException">if en is null
        /// </exception>
        public bool matchElement(System.String en)
        {
            if (en == null)
                throw new System.ArgumentException(" can't match Element name ");

            if (en.Equals("*") && context[0] != -1)
                return true;
            if (context[0] == -1)
                return false;
            return matchRawTokenString((context[0] == 0) ? rootIndex : context[context[0]], en);
        }
        /// <summary> Test whether the current element matches the given namespace URL and localname.
        /// URL, when set to "*", matches any namespace (including null), when set to null, defines a "always-no-match"
        /// ln is the localname that, when set to *, matches any localname
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">String
        /// </param>
        /// <param name="ln">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown entity.
        /// </exception>
        /// <exception cref="IllegalArgumentException"> if ln == null
        /// </exception>
        public bool matchElementNS(System.String URL, System.String ln)
        {
            if (context[0] == -1)
                return false;
            int i = getTokenLength((context[0] != 0) ? context[context[0]] : rootIndex);
            int offset = getTokenOffset((context[0] != 0) ? context[context[0]] : rootIndex);
            int preLen = (i >> 16) & 0xffff;
            int fullLen = i & 0xffff;
            if (URL != null && URL.Length == 0)
                URL = null;

            if (ln.Equals("*") || ((preLen != 0) ? matchRawTokenString(offset + preLen + 1, fullLen - preLen - 1, ln) : matchRawTokenString(offset, fullLen, ln)))
            {
                // no prefix, search for xmlns
                if (((URL != null) ? URL.Equals("*") : false)
                    || (resolveNS(URL, offset, preLen) == true))
                    return true;
                if (preLen == 3
                && matchRawTokenString(offset, preLen, "xml")
                && URL.Equals("http://www.w3.org/XML/1998/namespace"))
                    return true;
            }
            return false;
        }
        /// <summary> Match a string against a token with given offset and len, entities doesn't get resolved.</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="offset">int
        /// </param>
        /// <param name="len">int
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>

        private bool matchRawTokenString(int offset, int len, System.String s)
        {
            return compareRawTokenString(offset, len, s) == 0;
        }
        /// <summary> Match the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets matched against
        /// This method has to take care of the underlying encoding conversion
        /// but it <em> doesn't </em> resolve entity reference in the underlying document
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int   (index into the VTD token buffer)
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// 
        public bool matchRawTokenString(int index, System.String s)
        {
            int type = getTokenType(index);
            int len = (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS) ? getTokenLength(index) & 0xffff : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareRawTokenString(getTokenOffset(index), len, s) == 0;
        }
        /// <summary> Match a string with a token represented by a long (upper 32 len, lower 32 offset).</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="l">long
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// 
        private bool matchRawTokenString(long l, System.String s)
        {
            int len = (int)((l & MASK_TOKEN_FULL_LEN) >> 32);
            // a little hardcode is always bad
            //currentOffset = (int)l;
            return compareRawTokenString((int)l, len, s) == 0;
        }
        /// <summary> Match a string against a token with given offset and len, entities get resolved properly.
        /// Creation date: (11/24/03 1:37:42 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="offset">int
        /// </param>
        /// <param name="len">int
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        /// <exception cref="IllegalArguementException">if s is null
        /// </exception>
        private bool matchTokenString(int offset, int len, System.String s)
        {
            return compareTokenString(offset, len, s) == 0;
        }
        /// <summary> Match the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets matched against
        /// This method has to take care of the underlying encoding conversion
        /// as well as entity reference comparison
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>

        public bool matchTokenString(int index, System.String s)
        {
            int type = getTokenType(index);
            int len = (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS) ? getTokenLength(index) & 0xffff : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareTokenString(getTokenOffset(index), len, s) == 0;
        }
        /// <summary> Match a string against a "non-extractive" token represented by a long (upper 32 len, lower 32 offset).</summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="l">long
        /// </param>
        /// <param name="s">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>


        private bool matchTokenString(long l, System.String s)
        {
            int len = (int)(l >> 32) & 0xfffff;
            //int len = swap_bytes((int)(l>>32)) & 0xfffff;
            return compareTokenString((int)l, len, s) == 0;
        }


        /// <summary> Evaluate the namespace indicator in bit 31 and bit 30.
        /// Creation date: (11/27/03 5:38:51 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="i">int
        /// </param>
        private int NSval(int i)
        {

            return (int)(vtdBuffer.longAt(i) & MASK_TOKEN_NS_MARK);
        }
        /// <summary>
        /// overWrite is introduced in version 2.0 that allows you to 
        /// directly overwrite the XML content if the token is long enough
        /// If the operation is successful, white spaces will be used to fill
        /// the available token space, and there will be no need to regenerate
        /// the VTD and LCs
        /// <em> The current version (2.0) only allows overwrites on attribute value,
        /// character data, and CDATA</em>
        /// 
        /// Consider the XML below:
        ///  <a>  good </a> 
        /// After overwriting the token "good" with "bad," the new XML looks
        /// like:
        ///  <a>  bad  </a>
        /// as you can see, "goo" is replaced with "bad" character-by-character, 
        /// and the remaining "d" is replace with a white space  
        ///  
        /// </summary>
        /// <param name="index"></param>
        /// <param name="ba"></param>
        /// <returns></returns>
        public bool overWrite(int index, byte[] ba)
        {
            return overWrite(index, ba, 0, ba.Length);
        }
        /// <summary>
        ///  overWrite is introduced in version 2.0 that allows you to 
        /// directly overwrite the XML content if the token is long enough
        /// If the operation is successful, white spaces will be used to fill
        /// the available token space, and there will be no need to regenerate
        /// the VTD and LCs
        /// <em> The current version (2.0) only allows overwrites on attribute value,
        /// character data, and CDATA</em>
        /// 
        /// Consider the XML below:
        ///  <a>  good </a> 
        /// After overwriting the token "good" with "bad," the new XML looks
        /// like:
        ///  <a>  bad  </a>
        /// as you can see, "goo" is replaced with "bad" character-by-character, 
        /// and the remaining "d" is replace with a white space  
        ///  
        /// </summary>
        /// <param name="index"></param>
        /// <param name="ba"></param>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <returns>status of overwrite</returns>
        public bool overWrite(int index, byte[] ba, int offset, int len)
        {
            if (ba == null
                    || index >= this.vtdSize
                    || offset < 0
                    || offset + len > ba.Length)
                throw new ArgumentException("Illegal argument for overwrite");
            if (encoding >= VTDNav.FORMAT_UTF_16BE
                    && (((len & 1) == 1)
                    || ((offset & 1) == 1)))
            {
                // for UTF 16, len and offset must be integer multiple
                // of 2
                return false;
            }
            int t = getTokenType(index);
            if (t == VTDNav.TOKEN_CHARACTER_DATA
                    || t == VTDNav.TOKEN_ATTR_VAL
                    || t == VTDNav.TOKEN_CDATA_VAL)
            {
                int length = getTokenLength(index);
                if (length < len)
                    return false;
                int os = getTokenOffset(index);
                int temp = length - len;
                // get XML doc
                Array.Copy(ba, offset, XMLDoc.getBytes(), os, len);
                for (int k = 0; k < temp; )
                {
                    if (encoding < VTDNav.FORMAT_UTF_16BE)
                    {
                        // write white spaces
                        XMLDoc.getBytes()[os + len + k] = (byte)' ';
                        k++;
                    }
                    else
                    {
                        if (encoding == VTDNav.FORMAT_UTF_16BE)
                        {
                            XMLDoc.getBytes()[os + len + k] = 0;
                            XMLDoc.getBytes()[os + len + k + 1] = (byte)' ';
                        }
                        else
                        {
                            XMLDoc.getBytes()[os + len + k + 1] = 0;
                            XMLDoc.getBytes()[os + len + k] = (byte)' ';
                        }
                        k += 2;
                    }
                }
                return true;
            }
            return false;
        }
        /// <summary> Convert a vtd token into a double.
        /// Creation date: (12/8/03 2:28:31 PM)
        /// </summary>
        /// <returns> double
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public double parseDouble(int index)
        {
            //if (matchTokenString()
            int offset = getTokenOffset(index);
            long l = 0;
            int end = offset + getTokenLength(index);
            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            bool expneg = false;
            int ch;
            //past the last one by one

            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            while (offset < end)
            {
                // trim leading whitespaces
                if (!isWS(ch))
                    break;
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (offset > end)
                // all whitespace
                return System.Double.NaN;

            bool neg = (ch == '-');

            if (ch == '-' || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//get another one if it is sign.

            //left part of decimal
            double left = 0;
            while (offset <= end)
            {
                //must be <= since we get the next one at last.

                //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int dig = (int)System.Char.GetNumericValue((char)ch); //only consider decimal
                if (dig < 0)
                    break;

                left = left * 10 + dig;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //right part of decimal
            double right = 0;
            double scale = 1;
            if (ch == '.')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    right = right * 10 + dig;
                    scale *= 10;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
            }

            //exponent
            long exp = 0;
            if (ch == 'E' || ch == 'e')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
                expneg = (ch == '-'); //sign for exp
                if (ch == '+' || ch == '-')
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                } //skip the +/- sign

                int cur = offset;
                //remember the indx, used to find a invalid number like 1.23E

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    exp = exp * 10 + dig;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
                if (cur == offset)
                    return System.Double.NaN;
                //found a invalid number like 1.23E

                //if (expneg)
                //	exp = (-exp);
            }

            //anything left must be space
            while (offset <= end)
            {
                if (!isWS(ch))
                    return System.Double.NaN;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            double v = (double)left;
            if (right != 0)
                v += ((double)right) / (double)scale;

            if (exp != 0)
                v = (expneg) ? v / (System.Math.Pow(10, exp)) : v * System.Math.Pow(10, exp);

            return ((neg) ? (-v) : v);
        }

        /// <summary> Convert a vtd token into a float.
        /// we assume token type to be attr val or character data
        /// Creation date: (12/8/03 2:28:18 PM)
        /// </summary>
        /// <returns> float
        /// </returns>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public float parseFloat(int index)
        {

            int offset = getTokenOffset(index);
            long l = 0;
            int end = offset + getTokenLength(index);
            //past the last one by one
            int t = getTokenType(index);
            int ch;
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            while (offset <= end)
            {
                // trim leading whitespaces
                if (!isWS(ch))
                    break;
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (offset > end)
                // all whitespace
                throw new NavException("Empty string");

            bool neg = (ch == '-');

            if (ch == '-' || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            } //get another one if it is sign.

            //left part of decimal
            long left = 0;
            while (offset <= end)
            {
                //must be <= since we get the next one at last.

                //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int dig = (int)System.Char.GetNumericValue((char)ch); //only consider decimal
                if (dig < 0)
                    break;

                left = left * 10 + dig;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //right part of decimal
            long right = 0;
            long scale = 1;
            if (ch == '.')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    right = right * 10 + dig;
                    scale *= 10;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }
            }

            //exponent
            long exp = 0;
            if (ch == 'E' || ch == 'e')
            {
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
                bool expneg = (ch == '-'); //sign for exp
                if (ch == '+' || ch == '-')
                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                } //skip the +/- sign

                int cur = offset;
                //remember the indx, used to find a invalid number like 1.23E

                while (offset <= end)
                {
                    //must be <= since we get the next one at last.

                    //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    int dig = (int)System.Char.GetNumericValue((char)ch);
                    //only consider decimal
                    if (dig < 0)
                        break;

                    exp = exp * 10 + dig;

                    {
                        l = b ? getCharResolved(offset) : getChar(offset);
                        ch = (int)l;
                        offset += (int)(l >> 32);
                    }
                }

                if (cur == offset)
                    return System.Single.NaN;
                //found a invalid number like 1.23E

                if (expneg)
                    exp = (-exp);
            }

            //anything left must be space
            while (offset <= end)
            {
                if (!isWS(ch))
                    throw new NavException(toString(index));

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            double v = (double)left;
            if (right != 0)
            {
                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                v += ((double)right) / (double)scale;
            }

            if (exp != 0)
                v = v * System.Math.Pow(10, exp);


            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            float f = (float)v;

            //try to handle overflow/underflow
            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
            if (v >= (double)System.Single.MaxValue)
                f = System.Single.MaxValue;
            else
            {
                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1042'"
                //UPGRADE_TODO: The equivalent in .NET for field 'Float.MIN_VALUE' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                if (v <= (double)System.Single.Epsilon)
                {
                    //UPGRADE_TODO: The equivalent in .NET for field 'java.lang.Float.MIN_VALUE' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                    f = System.Single.Epsilon;
                }
            }
            if (neg)
                f = -f;
            return f;
        }
        /// <summary> Convert a vtd token into an int.
        /// This method will automatically strip off the leading and trailing
        /// we assume token type to be attr val or character data
        /// zero, unlike Integer.parseInt(int index)
        /// 
        /// Creation date: (12/8/03 2:32:22 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public int parseInt(int index)
        {
            return parseInt(index, 10);
        }
        /// <summary> Convert a vtd token into an int, with the given radix.
        /// we assume token type to be attr val or character data
        /// the first char can be either '+' or '-'
        /// Creation date: (12/16/03 1:21:20 PM)
        /// </summary>
        /// <returns> int
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="radix">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        protected internal int parseInt(int index, int radix)
        {
            if (radix < 2 || radix > 36)
                throw new System.FormatException("radix " + radix + " out of valid range");
            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);
            int offset = getTokenOffset(index);
            int endOffset = offset + getTokenLength(index);
            int ch;
            long l;
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            // trim leading whitespaces
            while ((ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r') && (offset <= endOffset))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            if (offset > endOffset)
                // all whitespace
                throw new System.FormatException(" empty string");

            bool neg = (ch == '-');
            if (neg || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//skip sign

            long result = 0;
            //long pos = 1;
            while (offset <= endOffset)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int digit = (int)System.Char.GetNumericValue((char)ch);
                if (digit < 0)
                    break;

                //Note: for binary we can simply shift to left to improve performance
                result = result * radix + digit;
                //pos *= radix;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (result > System.Int32.MaxValue)
                throw new System.FormatException("Overflow: " + toString(index));

            // take care of the trailing
            while (offset <= endOffset && isWS(ch))
            {

                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);

            }
            if (offset == (endOffset + 1))
                return (int)((neg) ? (-result) : result);
            else
                throw new System.FormatException(toString(index));
        }
        /// <summary> Convert a vtd token into a long.
        /// we assume token type to be attr val or character data
        /// Creation date: (12/8/03 2:32:59 PM)
        /// </summary>
        /// <returns> long
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        public long parseLong(int index)
        {
            return parseLong(index, 10);
        }
        /// <summary> Convert a vtd token into a long, with the given radix.
        /// the first char can be either '+' or '-', leading and trailing will be stripped
        /// we assume token type to be attr val or character data
        /// Creation date: (12/17/03 1:51:06 PM)
        /// </summary>
        /// <returns> long
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <param name="radix">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException">The exception if the underlying byte 
        /// content contains various errors. Notice that we are being conservative in making little assumption on
        /// the correctness of underlying byte content. This is because the VTD  can be generated by another
        /// machine such as a load-balancer.
        /// </exception>
        protected internal long parseLong(int index, int radix)
        {
            if (radix < 2 || radix > 36)
                throw new System.FormatException("radix " + radix + " out of valid range");

            int t = getTokenType(index);
            bool b = (t == VTDNav.TOKEN_CHARACTER_DATA) || (t == VTDNav.TOKEN_ATTR_VAL);

            int offset = getTokenOffset(index);
            int endOffset = offset + getTokenLength(index);
            long l;
            int ch;

            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            // trim leading whitespaces
            while ((ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r') && (offset <= endOffset))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }

            if (offset > endOffset)
                // all whitespace
                throw new System.FormatException(" empty string");

            bool neg = (ch == '-');
            if (neg || ch == '+')
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }//skip sign

            long result = 0;
            //long pos = 1;
            while (offset <= endOffset)
            {
                //UPGRADE_TODO: The equivalent in .NET for method 'Character.digit' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
                int digit = (int)System.Char.GetNumericValue((char)ch);
                if (digit < 0)
                    break;

                //Note: for binary we can simply shift to left to improve performance
                result = result * radix + digit;
                //pos *= radix;

                {
                    l = b ? getCharResolved(offset) : getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }
            }

            if (result > System.Int64.MaxValue)
                throw new System.FormatException("Overflow: " + toString(index));

            // take care of the trailing
            while (offset <= endOffset && isWS(ch))
            {
                l = b ? getCharResolved(offset) : getChar(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
            }
            if (offset == (endOffset + 1))
                return (long)((neg) ? (-result) : result);
            else
                throw new System.FormatException(toString(index));
        }
        /// <summary> Load the context info from ContextBuffer.
        /// Info saved including LC and current state of the context 
        /// Creation date: (11/16/03 6:59:20 PM)
        /// </summary>
        /// <ret>  boolean </ret>
        public virtual bool pop()
        {
            bool b = contextStack.load(stackTemp);
            if (b == false)
                return false;
            for (int i = 0; i < nestingLevel; i++)
            {
                context[i] = stackTemp[i];
            }

            l1index = stackTemp[nestingLevel];
            l2index = stackTemp[nestingLevel + 1];
            l3index = stackTemp[nestingLevel + 2];
            l2lower = stackTemp[nestingLevel + 3];
            l2upper = stackTemp[nestingLevel + 4];
            l3lower = stackTemp[nestingLevel + 5];
            l3upper = stackTemp[nestingLevel + 6];
            atTerminal = (stackTemp[nestingLevel + 7] == 1);
            LN = stackTemp[nestingLevel + 8];
            return true;
        }

        /// <summary> Load the context info from contextStack2.
        /// This method is dedicated for XPath evaluation.
        /// </summary>
        /// <returns>
        /// </returns>

        protected internal virtual bool pop2()
        {

            bool b = contextStack2.load(stackTemp);
            if (b == false)
                return false;
            for (int i = 0; i < nestingLevel; i++)
            {
                context[i] = stackTemp[i];
            }
            l1index = stackTemp[nestingLevel];
            l2index = stackTemp[nestingLevel + 1];
            l3index = stackTemp[nestingLevel + 2];
            l2lower = stackTemp[nestingLevel + 3];
            l2upper = stackTemp[nestingLevel + 4];
            l3lower = stackTemp[nestingLevel + 5];
            l3upper = stackTemp[nestingLevel + 6];
            atTerminal = (stackTemp[nestingLevel + 7] == 1);
            LN = stackTemp[nestingLevel + 8];
            return true;
        }
        /// <summary> Insert the method's description here.
        /// Creation date: (3/11/04 1:46:06 PM)
        /// </summary>

        public void printL2Buffer()
        {

            for (int i = 0; i < l1Buffer.size_Renamed_Field; i++)
                System.Console.Out.WriteLine(System.Convert.ToString(l1Buffer.longAt(i), 16));

            System.Console.Out.WriteLine("==================");
            for (int i = 0; i < l2Buffer.size_Renamed_Field; i++)
                System.Console.Out.WriteLine(System.Convert.ToString(l2Buffer.longAt(i), 16));
            System.Console.Out.WriteLine(" l1index :" + l1index + "  l2index :" + l2index + " l3index :" + l3index);
            System.Console.Out.WriteLine("          " + "l2lower :" + l2lower + " l3lower: " + l3lower);
            System.Console.Out.WriteLine("          " + "l2upper :" + l2upper + " l3upper: " + l3upper);
        }
        /// <summary> printLC for debugging purpose.
        /// Creation date: (3/12/04 6:07:40 PM)
        /// </summary>
        public void printLC()
        {
            //int a = 0, b = 0, c = 0;
            int depth = getCurrentDepth();
            if (depth == 1)
            {
                System.Console.Out.WriteLine("l1index --->" + l1index);
            }
            else if (depth == 2)
            {
                System.Console.Out.WriteLine("l2index --->" + l2index);
                System.Console.Out.WriteLine("l2lower --->" + l2lower);
                System.Console.Out.WriteLine("l2upper --->" + l2upper);
            }
            else if (depth == 3)
            {
                System.Console.Out.WriteLine("l3index --->" + l3index);
                System.Console.Out.WriteLine("l3lower --->" + l3lower);
                System.Console.Out.WriteLine("l3upper --->" + l3upper);
            }
        }
        /// <summary> Store the context info into the ContextBuffer.
        /// Info saved including LC and current state of the context 
        /// Creation date: (11/16/03 7:00:27 PM)
        /// </summary>
        public virtual void push()
        {

            for (int i = 0; i < nestingLevel; i++)
            {
                stackTemp[i] = context[i];
            }
            stackTemp[nestingLevel] = l1index;
            stackTemp[nestingLevel + 1] = l2index;
            stackTemp[nestingLevel + 2] = l3index;
            stackTemp[nestingLevel + 3] = l2lower;
            stackTemp[nestingLevel + 4] = l2upper;
            stackTemp[nestingLevel + 5] = l3lower;
            stackTemp[nestingLevel + 6] = l3upper;
            if (atTerminal)
                stackTemp[nestingLevel + 7] = 1;
            else
                stackTemp[nestingLevel + 7] = 0;
            stackTemp[nestingLevel + 8] = LN;
            contextStack.store(stackTemp);
        }
        /// <summary> Store the context info into the contextStack2.
        /// This method is reserved for XPath Evaluation
        /// 
        /// </summary>

        protected internal virtual void push2()
        {

            for (int i = 0; i < nestingLevel; i++)
            {
                stackTemp[i] = context[i];
            }
            stackTemp[nestingLevel] = l1index;
            stackTemp[nestingLevel + 1] = l2index;
            stackTemp[nestingLevel + 2] = l3index;
            stackTemp[nestingLevel + 3] = l2lower;
            stackTemp[nestingLevel + 4] = l2upper;
            stackTemp[nestingLevel + 5] = l3lower;
            stackTemp[nestingLevel + 6] = l3upper;
            if (atTerminal)
                stackTemp[nestingLevel + 7] = 1;
            else
                stackTemp[nestingLevel + 7] = 0;
            stackTemp[nestingLevel + 8] = LN;
            contextStack2.store(stackTemp);
        }

        /// <summary>  clear the contextStack2 after XPath evaluation
        /// 
        /// 
        /// </summary>
        protected internal void clearStack2()
        {
            contextStack2.size = 0;
        }


        /// <summary> This is for debugging purpose</summary>
        /// <param name="fib">
        /// </param>

        public virtual void sampleState(FastIntBuffer fib)
        {
            //		for(int i=0;i<context.)
            //			context[i] = -1;
            //		fib.append(context);
            if (context[0] >= 1)
                fib.append(l1index);


            if (context[0] >= 2)
            {
                fib.append(l2index);
                fib.append(l2lower);
                fib.append(l2upper);
            }

            if (context[0] >= 3)
            {
                fib.append(l3index);
                fib.append(l3lower);
                fib.append(l3upper);
            }
        }

        protected void resolveLC_l1()
        {
            if (l1index < 0 || l1index >= l1Buffer.size_Renamed_Field
        || context[1] != l1Buffer.upper32At(l1index))
            {
                if (l1index >= l1Buffer.size_Renamed_Field || l1index < 0)
                {
                    l1index = 0;
                }
                if (l1index + 1 < l1Buffer.size_Renamed_Field && context[1] != l1Buffer.upper32At(l1index + 1))
                {
                    int init_guess = (int)(l1Buffer.size_Renamed_Field * ((float)context[1] / vtdBuffer
                            .size_Renamed_Field));
                    if (l1Buffer.upper32At(init_guess) > context[1])
                    {
                        while (l1Buffer.upper32At(init_guess) != context[1])
                        {
                            init_guess--;
                        }
                    }
                    else if (l1Buffer.upper32At(init_guess) < context[1])
                    {
                        while (l1Buffer.upper32At(init_guess) != context[1])
                        {
                            init_guess++;
                        }
                    }
                    l1index = init_guess;
                }
                else
                {
                    if (context[1] >= l1Buffer.upper32At(l1index))
                    {
                        while (context[1] != l1Buffer.upper32At(l1index)
                            && l1index < l1Buffer.size_Renamed_Field)
                        {
                            l1index++;
                        }
                    }
                    else
                    {
                        while (context[1] != l1Buffer.upper32At(l1index)
                                && l1index >= 0)
                        {
                            l1index--;
                        }
                    }
                }
            }
        }

        protected void resolveLC_l2()
        {
            int temp = l1Buffer.lower32At(l1index);
            if (l2lower != temp)
            {
                l2lower = temp;
                // l2lower shouldn't be -1 !!!! l2lower and l2upper always get
                // resolved simultaneously
                l2index = l2lower;
                l2upper = l2Buffer.size_Renamed_Field - 1;
                for (int i = l1index + 1; i < l1Buffer.size_Renamed_Field; i++)
                {
                    temp = l1Buffer.lower32At(i);
                    if (temp != -1)
                    {
                        l2upper = temp - 1;
                        break;
                    }
                }
            } // intelligent guess again ??

            if (l2index < 0 || l2index >= l2Buffer.size_Renamed_Field
                    || context[2] != l2Buffer.upper32At(l2index))
            {

                if (l2index >= l2Buffer.size_Renamed_Field || l2index < 0)
                    l2index = l2lower;
                if (l2index + 1 < l2Buffer.size_Renamed_Field && context[2] == l2Buffer.upper32At(l2index + 1))
                    l2index = l2index + 1;
                else if (l2upper - l2lower >= 16)
                {
                    int init_guess = l2lower
                            + (int)((l2upper - l2lower)
                                    * ((float)context[2] - l2Buffer
                                            .upper32At(l2lower)) / (l2Buffer
                                    .upper32At(l2upper) - l2Buffer
                                    .upper32At(l2lower)));
                    if (l2Buffer.upper32At(init_guess) > context[2])
                    {
                        while (context[2] != l2Buffer.upper32At(init_guess))
                            init_guess--;
                    }
                    else if (l2Buffer.upper32At(init_guess) < context[2])
                    {
                        while (context[2] != l2Buffer.upper32At(init_guess))
                            init_guess++;
                    }
                    l2index = init_guess;
                }
                else if (context[2] < l2Buffer.upper32At(l2index))
                {

                    while (context[2] != l2Buffer.upper32At(l2index))
                    {
                        l2index--;
                    }
                }
                else
                {
                    while (context[2] != l2Buffer.upper32At(l2index))
                        l2index++;
                }
            }
        }

        protected virtual void resolveLC_l3()
        {
            int temp = l2Buffer.lower32At(l2index);
            if (l3lower != temp)
            {
                //l3lower and l3upper are always together
                l3lower = temp;
                // l3lower shouldn't be -1
                l3index = l3lower;
                l3upper = l3Buffer.size_Renamed_Field - 1;
                for (int i = l2index + 1; i < l2Buffer.size_Renamed_Field; i++)
                {
                    temp = l2Buffer.lower32At(i);
                    if (temp != -1)
                    {
                        l3upper = temp - 1;
                        break;
                    }
                }
            }

            if (l3index < 0 || l3index >= l3Buffer.size_Renamed_Field
                    || context[3] != l3Buffer.intAt(l3index))
            {
                if (l3index >= l3Buffer.size_Renamed_Field || l3index < 0)
                    l3index = l3lower;
                if (l3index + 1 < l3Buffer.size_Renamed_Field &&
                        context[3] == l3Buffer.intAt(l3index + 1))
                    l3index = l3index + 1;
                else if (l3upper - l3lower >= 16)
                {
                    int init_guess = l3lower
                            + (int)((l3upper - l3lower) * ((float)(context[3] - l3Buffer
                                    .intAt(l3lower)) / (l3Buffer.intAt(l3upper) - l3Buffer
                                    .intAt(l3lower))));
                    if (l3Buffer.intAt(init_guess) > context[3])
                    {
                        while (context[3] != l3Buffer.intAt(init_guess))
                            init_guess--;
                    }
                    else if (l3Buffer.intAt(init_guess) < context[3])
                    {
                        while (context[3] != l3Buffer.intAt(init_guess))
                            init_guess++;
                    }
                    l3index = init_guess;
                }
                else if (context[3] < l3Buffer.intAt(l3index))
                {
                    while (context[3] != l3Buffer.intAt(l3index))
                    {
                        l3index--;
                    }
                }
                else
                {
                    while (context[3] != l3Buffer.intAt(l3index))
                    {
                        l3index++;
                    }
                }
            }
        }
        /// <summary> Sync up the current context with location cache.
        /// This operation includes finding out l1index, l2index, 
        /// l3index and restores upper and lower bound info
        /// To improve efficieny this method employs some heuristic search algorithm.
        /// The result is that it is quite close to direct access.
        /// Creation date: (11/16/03 7:44:53 PM)
        /// </summary>
        /// <returns> int  The index of the NS URL
        /// </returns>
        protected virtual void resolveLC()
        {
            if (context[0] <= 0)
                return;
            resolveLC_l1();
            if (context[0] == 1)
                return;
            resolveLC_l2();
            if (context[0] == 2)
                return;
            resolveLC_l3();
        }
        /// <summary> Test whether the URL is defined in the scope. Null is allowed to
        /// indicate the name space is undefined. Creation date: (11/16/03 7:54:01
        /// PM)
        /// 
        /// </summary>
        /// <param name="URL">String
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown
        /// entity.
        /// </exception>
        protected internal int lookupNS()
        {
            if (context[0] == -1)
                throw new NavException("Can't lookup NS for document node");
            int i = getTokenLength((context[0] != 0) ? context[context[0]] : rootIndex);
            int offset = getTokenOffset((context[0] != 0) ? context[context[0]] : rootIndex);
            int preLen = (i >> 16) & 0xffff;
            return lookupNS(offset, preLen);

            //return resolveNS(URL, offset, preLen);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal int lookupNS(int offset, int len)
        {
            long l;
            bool hasNS = false;
            int size = vtdBuffer.size_Renamed_Field;
            // look for a match in the current hiearchy and return true
            for (int i = context[0]; i >= 0; i--)
            {
                int s = (i != 0) ? context[i] : rootIndex;
                switch (NSval(s))
                {

                    // checked the ns marking
                    case unchecked((int)0xc0000000):
                        s = s + 1;
                        if (s >= size)
                            break;
                        int type = getTokenType(s);

                        while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                        {
                            if (type == TOKEN_ATTR_NS)
                            {
                                // Get the token length
                                int temp = getTokenLength(s);
                                int preLen = ((temp >> 16) & 0xffff);
                                int fullLen = temp & 0xffff;
                                int os = getTokenOffset(s);
                                // xmlns found
                                if (temp == 5 && len == 0)
                                {
                                    return s + 1;
                                }
                                else if ((fullLen - preLen - 1) == len)
                                {
                                    // prefix length identical to local part of ns declaration
                                    bool a = true;
                                    for (int j = 0; j < len; j++)
                                    {
                                        if (getCharUnit(os + preLen + 1 + j) != getCharUnit(offset + j))
                                        {
                                            a = false;
                                            break;
                                        }
                                    }
                                    if (a == true)
                                    {
                                        return s + 1;
                                    }
                                }
                            }
                            //return (URL != null) ? true : false;
                            s += 2;
                            if (s >= size)
                                break;
                            type = getTokenType(s);
                        }
                        break;

                    case unchecked((int)0x80000000):
                        break;

                    default:  // check the ns existence, mark bit 31:30 to 11 or 10
                        int k = s + 1;
                        if (k >= size)
                            break;
                        type = getTokenType(k);

                        while ((type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS))
                        {
                            if (type == TOKEN_ATTR_NS)
                            {
                                // Get the token length
                                hasNS = true;
                                int temp = getTokenLength(k);
                                int preLen = ((temp >> 16) & 0xffff);
                                int fullLen = temp & 0xffff;
                                int os = getTokenOffset(k);
                                // xmlns found
                                if (temp == 5 && len == 0)
                                {
                                    l = vtdBuffer.longAt(s);
                                    hasNS = false;
                                    vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                                    return k + 1;

                                }
                                else if ((fullLen - preLen - 1) == len)
                                {
                                    // prefix length identical to local part of ns declaration
                                    bool a = true;
                                    for (int j = 0; j < len; j++)
                                    {
                                        if (getCharUnit(os + preLen + 1 + j) != getCharUnit(offset + j))
                                        {
                                            a = false;
                                            break;
                                        }
                                    }
                                    if (a == true)
                                    {
                                        l = vtdBuffer.longAt(s);
                                        //hasNS = false;
                                        vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                                        return k + 1;
                                    }
                                }
                            }
                            //return (URL != null) ? true : false;
                            k += 2;
                            if (k >= size)
                                break;
                            type = getTokenType(k);
                        }
                        l = vtdBuffer.longAt(s);
                        if (hasNS)
                        {
                            hasNS = false;
                            vtdBuffer.modifyEntry(s, l | unchecked((int)0x000000c000000000L));
                        }
                        else
                        {
                            vtdBuffer.modifyEntry(s, l | unchecked((int)0x0000008000000000L));
                        }
                        break;

                }
            }
            return 0;
        }
        /// <summary> Test whether the URL is defined in the document.
        /// Null is allowed to indicate the name space should be undefined.
        /// Creation date: (11/16/03 7:54:01 PM)
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="URL">String
        /// </param>
        /// <param name="offset">(offset of the prefix)
        /// </param>
        /// <param name="len">   (length of the prefix)
        /// </param>
        /// <exception cref="com.ximpleware.NavException">When there is any encoding conversion error or unknown entity.
        /// </exception>
        private bool resolveNS(System.String URL, int offset, int len)
        {
            int result = lookupNS(offset, len);
            switch (result)
            {
                case 0:
                    if (URL == null)
                        return true;
                    else
                        return false;
                default:
                    if (URL == null)
                    {
                        if (getTokenLength(result) == 0)
                            return true;
                        return false;
                    }
                    else
                        return matchNormalizedTokenString2(result, URL);
            }
        }
        /// <summary> A generic navigation method.
        /// Move the current to the element according to the direction constants
        /// If no such element, no position change and return false.
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are
        /// <pre>   			ROOT               0 </pre>	
        /// <pre> 		    PARENT  		   1 </pre>
        /// <pre>       	    FIRST_CHILD		   2 </pre>  
        /// <pre> 		    LAST_CHILD 		   3 </pre>
        /// <pre>    	  	    NEXT_SIBLING       4 </pre>
        /// <pre>      	    PREV_SIBLING       5 </pre>
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal.
        /// </exception>
        public virtual bool toElement(int direction)
        {
            int size;
            switch (direction)
            {

                case ROOT:  // to document element!
                    if (context[0] != 0)
                    {
                        /*for (int i = 1; i <= context[0]; i++) {
                        context[i] = 0xffffffff;
                        }*/
                        context[0] = 0;
                    }
                    atTerminal = false;
                    l1index = l2index = l3index = -1;
                    return true;

                case PARENT:
                    if (atTerminal == true)
                    {
                        atTerminal = false;
                        return true;
                    }
                    if (context[0] > 0)
                    {
                        //context[context[0]] = context[context[0] + 1] = 0xffffffff;
                        context[context[0]] = -1;
                        context[0]--;
                        return true;
                    }
                    else if (context[0] == 0)
                    {
                        context[0] = -1; //to be compatible with XPath Data model
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                //goto case FIRST_CHILD;

                case FIRST_CHILD:
                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    switch (context[0])
                    {

                        case -1:
                            context[0] = 0;
                            return true;

                        case 0:
                            if (l1Buffer.size_Renamed_Field > 0)
                            {
                                context[0] = 1;
                                l1index = (direction == FIRST_CHILD) ? 0 : (l1Buffer.size_Renamed_Field - 1);
                                context[1] = l1Buffer.upper32At(l1index);
                                //(int) (vtdToken >> 32);
                                return true;
                            }
                            else
                                return false;
                        //goto case 1;

                        case 1:
                            l2lower = l1Buffer.lower32At(l1index);
                            if (l2lower == -1)
                            {
                                return false;
                            }
                            context[0] = 2;
                            l2upper = l2Buffer.size_Renamed_Field - 1;
                            size = l1Buffer.size_Renamed_Field;
                            for (int i = l1index + 1; i < size; i++)
                            {
                                int temp = l1Buffer.lower32At(i);
                                if (temp != -1)
                                {
                                    l2upper = temp - 1;
                                    break;
                                }
                            }
                            //System.out.println(" l2 upper: " + l2upper + " l2 lower : " + l2lower);
                            l2index = (direction == FIRST_CHILD) ? l2lower : l2upper;
                            context[2] = l2Buffer.upper32At(l2index);
                            return true;


                        case 2:
                            l3lower = l2Buffer.lower32At(l2index);
                            if (l3lower == -1)
                            {
                                return false;
                            }
                            context[0] = 3;

                            l3upper = l3Buffer.size_Renamed_Field - 1;
                            size = l2Buffer.size_Renamed_Field;
                            for (int i = l2index + 1; i < size; i++)
                            {
                                int temp = l2Buffer.lower32At(i);
                                if (temp != -1)
                                {
                                    l3upper = temp - 1;
                                    break;
                                }
                            }
                            //System.out.println(" l3 upper : " + l3upper + " l3 lower : " + l3lower);
                            l3index = (direction == FIRST_CHILD) ? l3lower : l3upper;
                            context[3] = l3Buffer.intAt(l3index);

                            return true;


                        default:
                            if (direction == FIRST_CHILD)
                            {
                                size = vtdBuffer.size_Renamed_Field;
                                int index = context[context[0]] + 1;
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;

                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        //int depth = (((int)temp & 0x0f) << 4)
                                        //    | (((int)temp & 0xf000) >> 12);

                                        if (depth <= context[0])
                                        {
                                            return false;
                                        }
                                        else if (depth == (context[0] + 1))
                                        {
                                            context[0] += 1;
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }

                                    index++;
                                } // what condition  
                                return false;
                            }
                            else
                            {
                                int index = context[context[0]] + 1;
                                int last_index = -1;
                                size = vtdBuffer.size_Renamed_Field;
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                    //int depth = (((int)temp & 0x0f) << 4) | (((int)temp & 0xf000) >> 12);


                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;


                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        if (depth <= context[0])
                                        {
                                            break;
                                        }
                                        else if (depth == (context[0] + 1))
                                        {
                                            last_index = index;
                                        }
                                    }

                                    index++;
                                }
                                if (last_index == -1)
                                {
                                    return false;
                                }
                                else
                                {
                                    context[0] += 1;
                                    context[context[0]] = last_index;
                                    return true;
                                }
                            }
                        //break;

                    }
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    switch (context[0])
                    {

                        case -1:
                        case 0:
                            return false;

                        case 1:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l1index + 1 >= l1Buffer.size_Renamed_Field)
                                {
                                    return false;
                                }

                                l1index++; // global incremental
                            }
                            else
                            {
                                if (l1index - 1 < 0)
                                {
                                    return false;
                                }
                                l1index--; // global incremental
                            }
                            context[1] = l1Buffer.upper32At(l1index);
                            return true;

                        case 2:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l2index + 1 > l2upper)
                                {
                                    return false;
                                }
                                l2index++;
                            }
                            else
                            {
                                if (l2index - 1 < l2lower)
                                {
                                    return false;
                                }
                                l2index--;
                            }
                            context[2] = l2Buffer.upper32At(l2index);
                            return true;

                        case 3:
                            if (direction == NEXT_SIBLING)
                            {
                                if (l3index + 1 > l3upper)
                                {
                                    return false;
                                }
                                l3index++;
                            }
                            else
                            {
                                if (l3index - 1 < l3lower)
                                {
                                    return false;
                                }
                                l3index--;
                            }
                            context[3] = l3Buffer.intAt(l3index);
                            return true;

                        default:
                            //int index = context[context[0]] + 1;

                            if (direction == NEXT_SIBLING)
                            {
                                int index = context[context[0]] + 1;
                                size = vtdBuffer.size_Renamed_Field;
                                while (index < size)
                                {
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;


                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        //int depth = (((int)temp & 0x0f) << 4)
                                        //    | (((int)temp & 0xf000) >> 12);

                                        if (depth < context[0])
                                        {
                                            return false;
                                        }
                                        else if (depth == (context[0]))
                                        {
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }
                                    index++;
                                }
                                return false;
                            }
                            else
                            {
                                int index = context[context[0]] - 1;
                                while (index > context[context[0] - 1])
                                {
                                    // scan backforward
                                    long temp = vtdBuffer.longAt(index);
                                    int token_type = (int)((MASK_TOKEN_TYPE & temp) >> 60) & 0xf;
                                    //int token_type = ((int)temp & 0xf0) >> 4;

                                    if (token_type == TOKEN_STARTING_TAG)
                                    {
                                        int depth = (int)((MASK_TOKEN_DEPTH & temp) >> 52);
                                        // int depth = (((int)temp & 0x0f) << 4) | (((int)temp & 0xf000) >> 12);

                                        /*if (depth < context[0]) {
                                        return false;
                                        } else */
                                        if (depth == (context[0]))
                                        {
                                            context[context[0]] = index;
                                            return true;
                                        }
                                    }
                                    index--;
                                } // what condition          	    
                                return false;
                            }
                        //break;

                    }
                //goto default;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> A generic navigation method.
        /// Move the current to the element according to the direction constants and the element name
        /// If no such element, no position change and return false.
        /// "*" matches any element
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are 	<br>
        /// <pre>		ROOT            0  </pre>
        /// <pre>		PARENT          1  </pre>
        /// <pre>		FIRST_CHILD     2  </pre>
        /// <pre>		LAST_CHILD      3  </pre>
        /// <pre>		NEXT_SIBLING    4  </pre>
        /// <pre>		PREV_SIBLING    5  </pre>
        /// <br>
        /// for ROOT and PARENT, element name will be ignored.
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <param name="en">String     
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal. Or there are errors 
        /// in underlying byte representation of the document
        /// </exception>
        /// <exception cref="IllegalArguementException">if en is null
        /// </exception>
        public virtual bool toElement(int direction, System.String en)
        {
            //int size;
            int temp;
            int d;
            int val = 0;
            if (en == null)
                throw new System.ArgumentException(" Element name can't be null ");
            if (en.Equals("*"))
                return toElement(direction);
            switch (direction)
            {

                case ROOT:
                    return toElement(ROOT);


                case PARENT:
                    return toElement(PARENT);


                case FIRST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(FIRST_CHILD) == false)
                        return false;
                    // check current element name
                    if (matchElement(en) == false)
                    {
                        if (toElement(NEXT_SIBLING, en) == true)
                            return true;
                        else
                        {
                            //toParentElement();
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case LAST_CHILD;


                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(LAST_CHILD) == false)
                        return false;
                    if (matchElement(en) == false)
                    {
                        if (toElement(PREV_SIBLING, en) == true)
                            return true;
                        else
                        {
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            //toParentElement();
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];

                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    temp = context[d]; // store the current position

                    while (toElement(NEXT_SIBLING))
                    {
                        if (matchElement(en))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    temp = context[d]; // store the current position

                    while (toElement(PREV_SIBLING))
                    {
                        if (matchElement(en))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> A generic navigation method with namespace support.
        /// Move the current to the element according to the direction constants and the prefix and local names
        /// If no such element, no position change and return false.
        /// URL * matches any namespace, including undefined namespaces
        /// a null URL means hte namespace prefix is undefined for the element
        /// ln *  matches any localname
        /// Creation date: (12/2/03 1:43:50 PM)
        /// Legal direction constants are<br>
        /// <pre>		ROOT            0  </pre>
        /// <pre>		PARENT          1  </pre>
        /// <pre>		FIRST_CHILD     2  </pre>
        /// <pre>		LAST_CHILD      3  </pre>
        /// <pre>		NEXT_SIBLING    4  </pre>
        /// <pre>		PREV_SIBLING    5  </pre>
        /// <br>
        /// for ROOT and PARENT, element name will be ignored.
        /// If not ns enabled, return false immediately with no position change.
        /// </summary>
        /// <returns> boolean
        /// </returns>
        /// <param name="direction">int
        /// </param>
        /// <param name="en">String     
        /// </param>
        /// <exception cref="com.ximpleware.NavException"> When direction value is illegal. Or there are errors 
        /// in underlying byte representation of the document
        /// </exception>
        /// <exception cref="IllegalArguementException">if ln is null
        /// </exception>
        public virtual bool toElementNS(int direction, System.String URL, System.String ln)
        {
            //int size;
            int temp;
            int val = 0;
            int d; // temp location
            if (ns == false)
                return false;
            switch (direction)
            {

                case ROOT:
                    return toElement(ROOT);


                case PARENT:
                    return toElement(PARENT);


                case FIRST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(FIRST_CHILD) == false)
                        return false;
                    // check current element name
                    if (matchElementNS(URL, ln) == false)
                    {
                        if (toElementNS(NEXT_SIBLING, URL, ln) == true)
                            return true;
                        else
                        {
                            //toParentElement();
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case LAST_CHILD;


                case LAST_CHILD:
                    if (atTerminal)
                        return false;
                    if (toElement(LAST_CHILD) == false)
                        return false;
                    if (matchElementNS(URL, ln) == false)
                    {
                        if (toElementNS(PREV_SIBLING, URL, ln) == true)
                            return true;
                        else
                        {
                            //context[context[0]] = 0xffffffff;
                            context[0]--;
                            //toParentElement();
                            return false;
                        }
                    }
                    else
                        return true;
                //goto case NEXT_SIBLING;


                case NEXT_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    temp = context[d]; // store the current position
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    //if (d == 0)
                    //	return false;
                    while (toElement(NEXT_SIBLING))
                    {
                        if (matchElementNS(URL, ln))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                case PREV_SIBLING:
                    if (atTerminal)
                        return false;
                    d = context[0];
                    temp = context[d]; // store the current position
                    switch (d)
                    {

                        case -1:
                        case 0: return false;

                        case 1: val = l1index; break;

                        case 2: val = l2index; break;

                        case 3: val = l3index; break;

                        default:
                            break;

                    }
                    //if (d == 0)
                    //	return false;
                    while (toElement(PREV_SIBLING))
                    {
                        if (matchElementNS(URL, ln))
                        {
                            return true;
                        }
                    }
                    switch (d)
                    {

                        case 1: l1index = val; break;

                        case 2: l2index = val; break;

                        case 3: l3index = val; break;

                        default:
                            break;

                    }
                    context[d] = temp;
                    return false;


                default:
                    throw new NavException("illegal navigation options");

            }
        }
        /// <summary> This method normalizes a token into a string in a way that resembles DOM.
        /// The leading and trailing white space characters will be stripped.
        /// The entity and character references will be resolved
        /// Multiple whitespaces char will be collapsed into one.
        /// Whitespaces via entities will nonetheless be preserved.
        /// Creation date: (12/8/03 1:57:10 PM)
        /// </summary>
        /// <returns> String
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="NavException">When the encoding has errors
        /// </exception>
        public System.String toNormalizedString(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA && type != TOKEN_ATTR_VAL)
                return toRawString(index);
            int len = getTokenLength(index);
            if (len == 0)
                return "";
            int offset = getTokenOffset(index);
            int endOffset = len + offset - 1; // point to the last character
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            //System.String s = null;
            int ch;
            long l;

            // trim off the leading whitespaces

            while (true)
            {
                int temp = offset;
                {
                    l = getChar(offset);
                    ch = (int)l;
                    offset += (int)(l >> 32);
                }

                if (!isWS(ch))
                {
                    offset = temp;
                    break;
                }
            }

            bool d = false;
            while (offset <= endOffset)
            {
                l = getCharResolved(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
                if (isWS(ch) && getCharUnit(offset - 1) != ';')
                {
                    d = true;
                }
                else
                {
                    if (d == false)
                        sb.Append((char)ch);
                    // java only supports 16 bit unicode
                    else
                    {
                        sb.Append(' ');
                        sb.Append((char)ch);
                        d = false;
                    }
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Convert a segment of xml document into string
        /// entities not resolved
        /// </summary>
        /// <param name="os"> os in char</param>
        /// <param name="len">len in char</param>
        /// <returns></returns>
        public System.String toRawString(int os, int len)
        {
            int endOffset = len + os;
            int offset = os;
            long l;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            //if (encoding > FORMAT_WIN_1258)
            //{
            //    offset = offset >> 1;
            //    endOffset = endOffset >> 1;
            //}

            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l); //  only support 16 bit unit code
            }
            return sb.ToString();
        }
        /// <summary> Convert a token at the given index to a String, (built-in entity and char references not resolved)
        /// (entities and char references not expanded).
        /// Creation date: (11/16/03 7:28:49 PM)
        /// </summary>
        /// <returns> String
        /// </returns>
        /// <param name="index">int
        /// </param>
        /// <exception cref="NavException">When the encoding has errors
        /// </exception>
        public System.String toRawString(int index)
        {
            int type = getTokenType(index);
            int len;
            if (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);
            return toRawString(offset, len);
        }

        /// <summary>
        /// convert the document segment to String, entities resolved
        /// </summary>
        /// <param name="os">offset in char</param>
        /// <param name="len">length in char</param>
        /// <returns></returns>
        public System.String toString(int os, int len)
        {
            int endOffset = len + os;
            int offset = os;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            //System.String s = null;
            long l;
            /*if (encoding > FORMAT_WIN_1258)
            {
                offset = offset >> 1;
                endOffset = endOffset >> 1;
            }*/
            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l); // support 16 bit unit code
            }

            return sb.ToString();
        }
        /// <summary> Convert a token at the given index to a String, (entities and char references resolved).
        /// An attribute name or an element name will get the UCS2 string of qualified name 
        /// Creation date: (11/16/03 7:27:19 PM)
        /// </summary>
        /// <returns> String
        /// </returns>
        /// <param name="int">index
        /// </param>
        /// <exception cref="NavException">
        /// </exception>
        public System.String toString(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA && type != TOKEN_ATTR_VAL)
                return toRawString(index);

            int len = getTokenLength(index);
            int offset = getTokenOffset(index);

            return toString(offset, len);
        }

        /// <summary> This method compares two VTD tokens of VTDNav objects</summary>
        /// <param name="i1">
        /// </param>
        /// <param name="vn2">
        /// </param>
        /// <param name="i2">
        /// </param>
        /// <returns>
        /// 
        /// </returns>
        public bool matchTokens(int i1, VTDNav vn2, int i2)
        {
            return compareTokens(i1, vn2, i2) == 0;
        }

        /// <summary>
        /// <em>New in 2.0</em>
        /// This method compares two VTD tokens of VTDNav objects
        /// The behavior of this method is like compare the strings corresponds
        /// to i1 and i2
        /// </summary>
        /// <param name="i"></param>
        /// <param name="vn2"></param>
        /// <param name="i2"></param>
        /// <returns></returns>
        public int compareTokens(int i1, VTDNav vn2, int i2)
        {
            int t1, t2;
            int ch1, ch2;
            int endOffset1, endOffset2;
            long l;

            if (i1 == i2 && this == vn2)
                return 0;

            t1 = this.getTokenType(i1);
            t2 = vn2.getTokenType(i2);

            int offset1 = this.getTokenOffset(i1);
            int offset2 = vn2.getTokenOffset(i2);
            int len1 =
            (t1 == TOKEN_STARTING_TAG
                || t1 == TOKEN_ATTR_NAME
                || t1 == TOKEN_ATTR_NS)
                ? getTokenLength(i1) & 0xffff
                : getTokenLength(i1);
            int len2 =
                (t2 == TOKEN_STARTING_TAG
                    || t2 == TOKEN_ATTR_NAME
                    || t2 == TOKEN_ATTR_NS)
                    ? vn2.getTokenLength(i2) & 0xffff
                    : vn2.getTokenLength(i2);
            endOffset1 = len1 + offset1;
            endOffset2 = len2 + offset2;

            for (; offset1 < endOffset1 && offset2 < endOffset2; )
            {
                if (t1 == VTDNav.TOKEN_CHARACTER_DATA
                        || t1 == VTDNav.TOKEN_ATTR_VAL)
                {
                    l = this.getCharResolved(offset1);
                }
                else
                {
                    l = this.getChar(offset1);
                }
                ch1 = (int)l;
                offset1 += (int)(l >> 32);

                if (t2 == VTDNav.TOKEN_CHARACTER_DATA
                        || t2 == VTDNav.TOKEN_ATTR_VAL)
                {
                    l = vn2.getCharResolved(offset2);
                }
                else
                {
                    l = vn2.getChar(offset2);
                }
                ch2 = (int)l;
                offset2 += (int)(l >> 32);

                if (ch1 > ch2)
                    return 1;
                if (ch1 < ch2)
                    return -1;
            }

            if (offset1 == endOffset1
                    && offset2 < endOffset2)
                return -1;
            else if (offset1 < endOffset1
                    && offset2 == endOffset2)
                return 1;
            else
                return 0;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected internal int compareTokenString(int offset, int len, String s)
        {
            int i, l;
            long l1;
            //this.currentOffset = offset;
            int endOffset = offset + len;

            //       System.out.print("currentOffset :" + currentOffset);
            l = s.Length;
            //System.out.println(s);
            for (i = 0; i < l && offset < endOffset; i++)
            {
                l1 = getCharResolved(offset);
                int i1 = s[i];
                if (i1 < (int)l1)
                    return 1;
                if (i1 > (int)l1)
                    return -1;
                offset += (int)(l1 >> 32);
            }

            if (i == l && offset < endOffset)
                return 1;
            if (i < l && offset == endOffset)
                return -1;
            return 0;
        }
        /// <summary>
        /// <em>New in 2.0</em>
        /// Compare the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets compared against
        /// This method has to take care of the underlying encoding conversion
        /// but it <em> doesn't </em> resolve entity reference in the underlying document
        /// The behavior is the same as calling toRawString on index, then compare to s
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public int compareRawTokenString(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                (type == TOKEN_STARTING_TAG
                    || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                    ? getTokenLength(index) & 0xffff
                    : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            return compareRawTokenString(getTokenOffset(index), len, s);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected internal int compareRawTokenString(int offset, int len, String s)
        {
            int i, l;
            long l1;
            //this.currentOffset = offset;
            int endOffset = offset + len;


            //       System.out.print("currentOffset :" + currentOffset);
            l = s.Length;
            //System.out.println(s);
            for (i = 0; i < l && offset < endOffset; i++)
            {
                l1 = getChar(offset);
                int i1 = s[i];
                if (i1 < (int)l1)
                    return 1;
                if (i1 > (int)l1)
                    return -1;
                offset += (int)(l1 >> 32);
            }

            if (i == l && offset < endOffset)
                return 1;
            if (i < l && offset == endOffset)
                return -1;
            return 0;
        }
        /// <summary>
        /// <em>New in 2.0</em>
        /// Compare the string against the token at the given index value. When a token
        /// is an attribute name or starting tag, qualified name is what gets matched against
        /// This method has to take care of the underlying encoding conversion
        /// as well as entity reference comparison
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public int compareTokenString(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                (type == TOKEN_STARTING_TAG
                    || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                    ? getTokenLength(index) & 0xffff
                    : getTokenLength(index);
            // upper 16 bit is zero or for prefix

            //currentOffset = getTokenOffset(index);
            // point currentOffset to the beginning of the token
            // for UTF 8 and ISO, the performance is a little better by avoid calling getChar() everytime
            //return compareTokenString(getTokenOffset(index), len, s);
            if (type == TOKEN_CHARACTER_DATA
                || type == TOKEN_ATTR_VAL)
                return compareTokenString(getTokenOffset(index), len, s);
            else
                return compareRawTokenString(getTokenOffset(index), len, s);
        }

        /// <summary> This method writes the VTD+XML into an output streams</summary>
        /// <param name="os">
        /// </param>
        /// <throws>  IOException </throws>
        /// <throws>  IndexWriteException </throws>
        /// <summary> 
        /// </summary>
        public virtual void writeIndex(System.IO.Stream os)
        {
            IndexHandler.writeIndex_L3(1,
                 this.encoding,
                 this.ns,
                 true,
                 this.nestingLevel - 1,
                 3,
                 this.rootIndex,
                 this.XMLDoc.getBytes(),
                 this.docOffset,
                 this.docLen,
                 (FastLongBuffer)this.vtdBuffer,
                 (FastLongBuffer)this.l1Buffer,
                 (FastLongBuffer)this.l2Buffer,
                 (FastIntBuffer)this.l3Buffer,
                 os);
        }

        /// <summary> This method writes the VTD+XML file into a file of the given name</summary>
        /// <param name="fileName">
        /// </param>
        /// <throws>  IOException </throws>
        /// <throws>  IndexWriteException </throws>
        /// <summary> 
        /// </summary>
        public void writeIndex(System.String fileName)
        {
            //UPGRADE_TODO: Constructor 'java.io.FileOutputStream.FileOutputStream' was converted to 'System.IO.FileStream.FileStream' which has a different behavior. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1073_javaioFileOutputStreamFileOutputStream_javalangString'"
            System.IO.FileStream fos = new System.IO.FileStream(fileName, System.IO.FileMode.Create);
            writeIndex(fos);
            fos.Close();
        }
        /// <summary>
        /// Precompute the size of VTD+XML index without actully generating it
        /// </summary>
        /// <returns>the size of VTD+XML index</returns>
        public long getIndexSize()
        {
            int size;
            if ((docLen & 7) == 0)
                size = docLen;
            else
                size = ((docLen >> 3) + 1) << 3;

            size += (vtdBuffer.size_Renamed_Field << 3) +
                    (l1Buffer.size_Renamed_Field << 3) +
                    (l2Buffer.size_Renamed_Field << 3);

            if ((l3Buffer.size_Renamed_Field & 1) == 0)
            { //even
                size += l3Buffer.size_Renamed_Field << 2;
            }
            else
            {
                size += (l3Buffer.size_Renamed_Field + 1) << 2; //odd
            }
            return size + 64;
        }
        /// <summary>
        /// Get the string length as if the token is converted into a UCS string 
        /// (entity not resolved)
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public int getRawStringLength(int index)
        {
            int type = getTokenType(index);
            int len = 0, len1 = 0;
            if (type == TOKEN_STARTING_TAG || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            if (encoding != VTDNav.FORMAT_UTF8 &&
                encoding != VTDNav.FORMAT_UTF_16BE &&
                encoding != VTDNav.FORMAT_UTF_16LE)
            {
                return len;
            }
            int offset = getTokenOffset(index);
            int endOffset = offset + len;
            long l;
            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                len1++;
            }
            return len1;
        }
        /// <summary>
        /// getStringLength return the string length of a token as if the token is converted into 
        /// a string (entity resolved)
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public int getStringLength(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA && type != TOKEN_ATTR_VAL)
                return getRawStringLength(index);
            int len = 0, len1 = 0;
            len = getTokenLength(index);
            int offset = getTokenOffset(index);
            int endOffset = offset + len;
            long l;

            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                len1++;
            }
            return len1;
        }
        /// <summary>
        /// Get the string length of a token as if it is converted into a normalized 
        /// UCS string
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public int getNormalizedStringLength(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA &&
                    type != TOKEN_ATTR_VAL)
                return getRawStringLength(index);
            long l;
            int len, len1 = 0;
            len = getTokenLength(index);
            if (len == 0)
                return 0;
            int offset = getTokenOffset(index);
            int endOffset = len + offset - 1; // point to the last character
            //StringBuffer sb = new StringBuffer(len);

            int ch;
            // trim off the leading whitespaces

            while (true)
            {
                int temp = offset;
                l = getChar(offset);

                ch = (int)l;
                offset += (int)(l >> 32);

                if (!isWS(ch))
                {
                    offset = temp;
                    break;
                }
            }

            bool d = false;
            while (offset <= endOffset)
            {
                l = getCharResolved(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
                if (isWS(ch) && getCharUnit(offset - 1) != ';')
                {
                    d = true;
                }
                else
                {
                    if (d == false)
                        len1++; // java only supports 16 bit unicode
                    else
                    {
                        len1 = len1 + 2;
                        d = false;
                    }
                }
            }

            return len1;
        }
        /// <summary>
        /// Duplicate the VTDNav instance with shared XML, VTD and LC buffers
        /// This method may be useful for parallel XPath evaluation
        /// The node Position is at root element
        /// </summary>
        /// <returns>an instance of VTDNav</returns>
        public virtual VTDNav duplicateNav()
        {
            return new VTDNav(rootIndex,
                encoding,
                ns,
                nestingLevel - 1,
                XMLDoc,
                vtdBuffer,
                l1Buffer,
                l2Buffer,
                l3Buffer,
                docOffset,
                docLen
                );
        }
        /// <summary>
        /// Duplicate the VTDNav instance with shared XML, VTD and LC buffers
        /// This method may be useful for parallel XPath evaluation
        /// The node Position is copied over.
        /// </summary>
        /// <returns>an instance of VTDNav</returns>
        public virtual VTDNav cloneNav()
        {
            VTDNav vn = new VTDNav(rootIndex,
                    encoding,
                    ns,
                    nestingLevel - 1,
                    XMLDoc,
                    vtdBuffer,
                    l1Buffer,
                    l2Buffer,
                    l3Buffer,
                    docOffset,
                    docLen
                    );
            vn.atTerminal = this.atTerminal;
            vn.LN = this.LN;
            if (this.context[0] > -1)
                Array.Copy(this.context, 0, vn.context, 0, this.context[0] + 1);
            else
                this.context[0] = -1;
            vn.l1index = l1index;
            if (getCurrentDepth() > 1)
            {
                vn.l2index = this.l2index;
                vn.l2upper = l2upper;
                vn.l2lower = l2lower;
            }
            if (getCurrentDepth() > 2)
            {
                vn.l3lower = l3lower;
                vn.l3index = l3index;
                vn.l3upper = l3upper;
            }
            return vn;
        }
        /// <summary>
        /// Write VTDNav's internal structure into an OutputStream (XML not written out)
        /// </summary>
        /// <param name="fileName"></param>
        public void writeSeparateIndex(String fileName)
        {
            System.IO.FileStream fos = new System.IO.FileStream(fileName, System.IO.FileMode.Create);
            writeIndex(fos);
            fos.Close();

        }
        /// <summary>
        /// Write VTDNav's VTD and LCs into an OutputStream (XML not written out)
        /// </summary>
        /// <param name="os"></param>
        public virtual void writeSeparateIndex(System.IO.Stream os)
        {
            IndexHandler.writeSeparateIndex_L3((byte)2,
                this.encoding,
                this.ns,
                true,
                this.nestingLevel - 1,
                3,
                this.rootIndex,
                // this.XMLDoc.getBytes(),
                this.docOffset,
                this.docLen,
                (FastLongBuffer)this.vtdBuffer,
                (FastLongBuffer)this.l1Buffer,
                (FastLongBuffer)this.l2Buffer,
                (FastIntBuffer)this.l3Buffer,
                os);
        }

        /// <summary>
        /// Test the start of token content at index i matches the content 
        /// of s, notice that this is to save the string allocation cost of 
        /// using String's built-in startsWidth 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public bool startsWith(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                    (type == TOKEN_STARTING_TAG
                            || type == TOKEN_ATTR_NAME
                            || type == TOKEN_ATTR_NS)
                            ? getTokenLength(index) & 0xffff
                            : getTokenLength(index);
            int offset = getTokenOffset(index);
            long l1;
            int i, l;
            int endOffset = offset + len;
            bool b = (type == TOKEN_ATTR_VAL
                || type == TOKEN_CHARACTER_DATA);
            l = s.Length;
            if (l > len)
                return false;

            for (i = 0; i < l && offset < endOffset; i++)
            {
                if (b)
                    l1 = getCharResolved(offset);
                else
                    l1 = getChar(offset);
                int i1 = s[i];
                if (i1 != (int)l1)
                    return false;
                offset += (int)(l1 >> 32);
            }
            return true;
        }

        /// <summary>
        /// Test the end of token content at index i matches the content 
        /// of s, notice that this is to save the string allocation cost of 
        /// using String's built-in endsWidth 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>

        public bool endsWith(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                    (type == TOKEN_STARTING_TAG
                            || type == TOKEN_ATTR_NAME
                            || type == TOKEN_ATTR_NS)
                            ? getTokenLength(index) & 0xffff
                            : getTokenLength(index);
            int offset = getTokenOffset(index);
            long l1;
            int i, l, i2;
            bool b = (type == TOKEN_ATTR_VAL
                || type == TOKEN_CHARACTER_DATA);
            //int endOffset = offset + len; 

            //       System.out.print("currentOffset :" + currentOffset); 
            l = s.Length;
            if (l > len)
                return false;
            i2 = getStringLength(index);
            if (l > i2)
                return false;
            i2 = i2 - l; // calculate the # of chars to be skipped 
            // eat away first several chars 
            for (i = 0; i < i2; i++)
            {
                if (b)
                    l1 = getCharResolved(offset);
                else
                    l1 = getChar(offset);
                offset += (int)(l1 >> 32);
            }
            //System.out.println(s); 
            for (i = 0; i < l; i++)
            {
                if (b)
                    l1 = getCharResolved(offset);
                else
                    l1 = getChar(offset);
                int i1 = s[i];
                if (i1 != (int)l1)
                    return false;
                offset += (int)(l1 >> 32);
            }
            return true;
        }

        /// <summary>
        /// Test whether a given token contains s. notie that this function 
        /// directly operates on the byte content of the token to avoid string creation 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public bool contains(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                    (type == TOKEN_STARTING_TAG
                            || type == TOKEN_ATTR_NAME
                            || type == TOKEN_ATTR_NS)
                            ? getTokenLength(index) & 0xffff
                            : getTokenLength(index);
            int offset = getTokenOffset(index);
            long l1;
            int i, l, i2;
            int endOffset = offset + len;
            bool b = (type == TOKEN_ATTR_VAL
                || type == TOKEN_CHARACTER_DATA);

            //       System.out.print("currentOffset :" + currentOffset); 
            int gOffset = offset;
            l = s.Length;
            if (l > len)
                return false;
            //System.out.println(s); 
            while (offset < endOffset)
            {
                gOffset = offset;
                for (i = 0; i < l && gOffset < endOffset; i++)
                {
                    if (b)
                        l1 = getCharResolved(gOffset);
                    else
                        l1 = getChar(gOffset);
                    int i1 = s[i];
                    gOffset += (int)(l1 >> 32);
                    if (i == 0)
                        offset = gOffset;
                    if (i1 != (int)l1)
                        break;
                }
                if (i == l)
                    return true;
            }
            return false;
        }
        /// <summary>
        /// Convert the byte content segment (in terms of offset and length) to 
        /// String, lower case characters are converted to upper case 
        /// </summary>
        /// <param name="os"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal String toStringUpperCase(int os, int len)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                if ((int)l > 96 && (int)l < 123)
                    sb.Append((char)(l - 32));
                else
                    sb.Append((char)l);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Convert the byte content segment (in terms of offset and length) to 
        /// String, upper case characters are converted to lower case 
        /// Notice this is more efficient than call toString, then can toLowerCase
        /// </summary>
        /// <param name="os"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal String toStringLowerCase(int os, int len)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                if ((int)l > 64 && (int)l < 91)
                    sb.Append((char)(l + 32));
                else
                    sb.Append((char)l);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Convert a token at the given index to a String and any upper case
        /// character will be converted to lower case, (entities and char
        /// references resolved). An attribute name or an element name will get the
        /// UCS2 string of qualified name
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String toStringLowerCase(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA &&
                    type != TOKEN_ATTR_VAL)
                return toRawStringLowerCase(index);
            int len;
            len = getTokenLength(index);

            int offset = getTokenOffset(index);
            return toStringLowerCase(offset, len);
        }

        /// <summary>
        /// Convert a token at the given index to a String and any lower case
        /// character will be converted to upper case, (entities and char
        /// references resolved). An attribute name or an element name will get the
        /// UCS2 string of qualified name
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String toStringUpperCase(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA &&
                    type != TOKEN_ATTR_VAL)
                return toRawStringUpperCase(index);
            int len;
            len = getTokenLength(index);

            int offset = getTokenOffset(index);
            return toStringUpperCase(offset, len);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="os"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal String toRawStringLowerCase(int os, int len)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                if ((int)l > 64 && (int)l < 91)
                    sb.Append((char)(l + 32));
                else
                    sb.Append((char)l);
            }
            return sb.ToString();
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="os"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        protected internal String toRawStringUpperCase(int os, int len)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(len);
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                if ((int)l > 96 && (int)l < 123)
                    sb.Append((char)(l - 32));
                else
                    sb.Append((char)l);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Convert a token at the given index to a String, lower case chars
        /// get converted into upper case 
        /// (entities and char references not expanded).
        /// </summary>
        /// <param name="index"> VTD index</param>
        /// <returns></returns>
        public String toRawStringUpperCase(int index)
        {
            int type = getTokenType(index);
            int len;
            if (type == TOKEN_STARTING_TAG
                || type == TOKEN_ATTR_NAME
                || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);
            return toRawStringUpperCase(offset, len);
        }
        /// <summary>
        /// Convert a token at the given index to a String, upper case chars
        /// get converted into lower case 
        /// (entities and char references not expanded).
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String toRawStringLowerCase(int index)
        {
            int type = getTokenType(index);
            int len;
            if (type == TOKEN_STARTING_TAG
                || type == TOKEN_ATTR_NAME
                || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);
            return toRawStringLowerCase(offset, len);
        }

        /// <summary>
        /// Get content fragment returns a long encoding the offset and length of the byte segment of
        /// the content of current element, which is the byte segment between the starting tag and 
        /// ending tag, -1 is returned if the current element is an empty element
        /// </summary>
        /// <returns>long whose upper 32 bite is length, lower 32 bit is offset</returns>
        public long getContentFragment()
        {
            // a little scanning is needed
            // has next sibling case
            // if not
            int temp, so2, d, i;

            int depth = getCurrentDepth();
            //		 document length and offset returned if depth == -1
            if (depth == -1)
            {
                i = vtdBuffer.lower32At(0);
                if (i == 0)
                    return ((long)docLen) << 32 | docOffset;
                else
                    return ((long)(docLen - 32)) | 32;
            }


            long l = getOffsetAfterHead();
            if (l < 0)
                return -1L;
            int so = (int)l;
            int length = 0;


            // for an element with next sibling
            if (toElement(NEXT_SIBLING))
            {

                temp = getCurrentIndex();
                // rewind
                while (getTokenDepth(temp) < depth)
                {
                    temp--;
                }
                //temp++;
                so2 = getTokenOffset(temp) - 1;
                // look for the first '>'
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                while (getCharUnit(so2) != '/')
                {
                    so2--;
                }
                while (getCharUnit(so2) != '<')
                {
                    so2--;
                }
                length = so2 - so;
                toElement(PREV_SIBLING);
                if (encoding <= FORMAT_WIN_1258)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }

            // for root element
            if (depth == 0)
            {
                temp = vtdBuffer.size_Renamed_Field - 1;
                bool b = false;
                so2 = 0;
                while (getTokenDepth(temp) == -1)
                {
                    temp--; // backward scan
                    b = true;
                }
                if (b == false)
                    so2 =
                        (encoding <= FORMAT_WIN_1258)
                            ? (docOffset + docLen - 1)
                            : ((docOffset + docLen) >> 1) - 1;
                else
                    so2 = getTokenOffset(temp + 1);
                while (getCharUnit(so2) != '>')
                {
                    so2--;
                }
                while (getCharUnit(so2) != '/')
                {
                    so2--;
                }
                while (getCharUnit(so2) != '<')
                {
                    so2--;
                }
                length = so2 - so;
                if (encoding <= FORMAT_WIN_1258)
                    return ((long)length) << 32 | so;
                else
                    return ((long)length) << 33 | (so << 1);
            }
            // for a non-root element with no next sibling
            temp = getCurrentIndex() + 1;
            int size = vtdBuffer.size_Renamed_Field;
            // temp is not the last entry in VTD buffer
            if (temp < size)
            {
                while (temp < size && getTokenDepth(temp) >= depth)
                {
                    temp++;
                }
                if (temp != size)
                {
                    d =
                        depth
                            - getTokenDepth(temp)
                            + ((getTokenType(temp) == TOKEN_STARTING_TAG) ? 1 : 0);
                    so2 = getTokenOffset(temp) - 1;
                    i = 0;
                    // scan backward
                    while (i < d)
                    {
                        if (getCharUnit(so2) == '>')
                            i++;
                        so2--;
                    }
                    while (getCharUnit(so2) != '/')
                    {
                        so2--;
                    }
                    while (getCharUnit(so2) != '<')
                    {
                        so2--;
                    }
                    length = so2 - so;
                    if (encoding <= FORMAT_WIN_1258)
                        return ((long)length) << 32 | so;
                    else
                        return ((long)length) << 33 | (so << 1);
                }
                /*
                 * int so2 = getTokenOffset(temp - 1) - 1; int d = depth -
                 * getTokenDepth(temp - 1); int i = 0; while (i < d) { if
                 * (getCharUnit(so2) == '>') { i++; } so2--; } length = so2 - so +
                 * 2; if (encoding < 3) return ((long) length) < < 32 | so; else
                 * return ((long) length) < < 33 | (so < < 1);
                 */
            }
            // temp is the last entry
            // scan forward search for /> or </cc>

            so2 =
                (encoding <= FORMAT_WIN_1258)
                    ? (docOffset + docLen - 1)
                    : ((docOffset + docLen) >> 1) - 1;
            //int d;

            d = depth + 1;

            i = 0;
            while (i < d)
            {
                if (getCharUnit(so2) == '>')
                {
                    i++;
                }
                so2--;
            }
            while (getCharUnit(so2) != '/')
            {
                so2--;
            }
            while (getCharUnit(so2) != '<')
            {
                so2--;
            }

            length = so2 - so;

            if (encoding <= FORMAT_WIN_1258)
                return ((long)length) << 32 | so;
            else
                return ((long)length) << 33 | (so << 1);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sb"></param>
        /// <param name="index"></param>
        protected internal void toString(System.Text.StringBuilder sb, int index)
        {

            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA &&
                    type != TOKEN_ATTR_VAL)
                toRawString(sb, index);
            int len;
            len = getTokenLength(index);

            int offset = getTokenOffset(index);
            toString(offset, len, sb);
        }

        protected internal void toRawString(int os, int len, System.Text.StringBuilder sb)
        {
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getChar(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l);
            }
        }

        protected internal void toString(int os, int len, System.Text.StringBuilder sb)
        {
            int offset = os;
            int endOffset = os + len;
            long l;
            while (offset < endOffset)
            {
                l = getCharResolved(offset);
                offset += (int)(l >> 32);
                sb.Append((char)l);
            }
        }

        protected internal String toRawString(System.Text.StringBuilder sb, int index)
        {
            int type = getTokenType(index);
            int len;
            if (type == TOKEN_STARTING_TAG
                || type == TOKEN_ATTR_NAME
                || type == TOKEN_ATTR_NS)
                len = getTokenLength(index) & 0xffff;
            else
                len = getTokenLength(index);
            int offset = getTokenOffset(index);
            return toRawString(offset, len);
        }

        protected internal String getXPathStringVal()
        {
            int index = getCurrentIndex() + 1;
            int tokenType, depth, t = 0, length, i = 0;
            int dp = context[0];
            //int size = vtdBuffer.size_Renamed_Field;
            // store all text tokens underneath the current element node
            while (index < vtdSize)
            {
                tokenType = getTokenType(index);
                depth = getTokenDepth(index);
                if (depth < dp ||
                        (depth == dp && tokenType == VTDNav.TOKEN_STARTING_TAG))
                {
                    break;
                }

                if (tokenType == VTDNav.TOKEN_CHARACTER_DATA
                        || tokenType == VTDNav.TOKEN_CDATA_VAL)
                {
                    length = getTokenLength(index);
                    t += length;
                    fib.append(index);
                    if (length > VTDGen.MAX_TOKEN_LENGTH)
                    {
                        while (length > VTDGen.MAX_TOKEN_LENGTH)
                        {
                            length -= VTDGen.MAX_TOKEN_LENGTH;
                            i++;
                        }
                        index += i + 1;
                    }
                    else
                        index++;
                    continue;
                    //
                }
                else if (tokenType == VTDNav.TOKEN_ATTR_NAME
                        || tokenType == VTDNav.TOKEN_ATTR_NS)
                {
                    index = index + 2;
                    continue;
                }
                index++;
            }

            // calculate the total length
            System.Text.StringBuilder sb = new System.Text.StringBuilder(t);

            for (t = 0; t < fib.size_Renamed_Field; t++)
            {
                toString(sb, t);
            }

            // clear the fib and return a string
            return sb.ToString();
        }

        /// <summary>
        /// This method takes a vtd index, and recover its correspondin
        /// node position, the index can only be of node type element,
        /// document, attribute name, attribute value or character data,
        /// or CDATA
        /// </summary>
        /// <param name="index"></param>
        public virtual void recoverNode(int index)
        {
            if (index < 0 || index >= vtdSize)
                throw new NavException("Invalid VTD index");
            int t;
            int type = getTokenType(index);
            if (//type == VTDNav.TOKEN_COMMENT ||
                //	type == VTDNav.TOKEN_PI_NAME ||
                    type == VTDNav.TOKEN_PI_VAL ||
                    type == VTDNav.TOKEN_DEC_ATTR_NAME ||
                    type == VTDNav.TOKEN_DEC_ATTR_VAL ||
                    type == VTDNav.TOKEN_ATTR_VAL)
                throw new NavException("Token type not yet supported");

            // get depth
            int d = getTokenDepth(index);
            // handle document node;
            switch (d)
            {
                case -1:
                    context[0] = -1;
                    if (index != 0)
                    {
                        LN = index;
                        atTerminal = true;
                    }
                    return;
                case 0:
                    context[0] = 0;
                    if (index != rootIndex)
                    {
                        LN = index;
                        atTerminal = true;
                    }
                    return;
            }
            context[0] = d;
            if (type != VTDNav.TOKEN_STARTING_TAG)
            {
                LN = index;
                atTerminal = true;
            }
            // search LC level 1
            recoverNode_l1(index);

            if (d == 1)
                return;
            // search LC level 2
            recoverNode_l2(index);
            if (d == 2)
            {
                //resolveLC();
                return;
            }
            // search LC level 3
            recoverNode_l3(index);
            if (d == 3)
            {
                //resolveLC();
                return;
            }
            // scan backward
            if (type == VTDNav.TOKEN_STARTING_TAG)
            {
                context[d] = index;
            }
            else
            {
                t = index - 1;
                while (!(getTokenType(t) == VTDNav.TOKEN_STARTING_TAG &&
                        getTokenDepth(t) == d))
                {
                    t--;
                }
                context[d] = t;
            }
            t = context[d] - 1;
            d--;
            while (d > 3)
            {
                while (!(getTokenType(t) == VTDNav.TOKEN_STARTING_TAG &&
                        getTokenDepth(t) == d))
                {
                    t--;
                }
                context[d] = t;
                d--;
            }
            //resolveLC();		
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        protected internal void recoverNode_l1(int index)
        {
            int i;
            if (context[1] == index)
            {

            }
            else if (l1index !=-1 && context[1] > index
                    && l1index + 1 < l1Buffer.size_Renamed_Field
                    && l1Buffer.upper32At(l1index + 1) < index)
            {

            }
            else
            {
                i = (index / vtdSize) * l1Buffer.size_Renamed_Field;
                if (i >= l1Buffer.size_Renamed_Field)
                    i = l1Buffer.size_Renamed_Field - 1;

                if (l1Buffer.upper32At(i) < index)
                {
                    while (i < l1Buffer.size_Renamed_Field - 1 &&
                            l1Buffer.upper32At(i) < index)
                    {
                        i++;
                    }
                    if (l1Buffer.upper32At(i) > index)
                        i--;
                }
                else
                {
                    while (l1Buffer.upper32At(i) > index)
                    {
                        i--;
                    }
                }
                context[1] = l1Buffer.upper32At(i);
                l1index = i;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        protected void recoverNode_l2(int index)
        {
            int i = l1Buffer.lower32At(l1index);

            if (l2lower != i)
            {
                l2lower = i;
                // l2lower shouldn't be -1 !!!! l2lower and l2upper always get
                // resolved simultaneously
                //l2index = l2lower;
                l2upper = l2Buffer.size_Renamed_Field - 1;
                for (int k = l1index + 1; k < l1Buffer.size_Renamed_Field; k++)
                {
                    i = l1Buffer.lower32At(k);
                    if (i != -1)
                    {
                        l2upper = i - 1;
                        break;
                    }
                }
            }
            // guess what i would be in l2 cache
            int t1 = l2Buffer.upper32At(l2lower);
            int t2 = l2Buffer.upper32At(l2upper);
            //System.out.print("   t2  ==>"+t2+"   t1  ==>"+t1);
            i = System.Math.Min(l2lower + (int)(((float)(index - t1) / (t2 - t1 + 1)) * (l2upper - l2lower)), l2upper);
            //System.out.print("  i1  "+i);
            while (i < l2Buffer.size_Renamed_Field - 1 && l2Buffer.upper32At(i) < index)
            {
                i++;
            }
            //System.out.println(" ==== i2    "+i+"    index  ==>  "+index);

            while (l2Buffer.upper32At(i) > index && i > 0)
                i--;
            context[2] = l2Buffer.upper32At(i);
            l2index = i;
            //System.out.println("l2lower ==>"+l2lower+"  l2upper==>"+l2upper+"   l2index==> "+l2index);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        protected virtual void recoverNode_l3(int index)
        {
            int i = l2Buffer.lower32At(l2index);

            if (l3lower != i)
            {
                //l3lower and l3upper are always together
                l3lower = i;
                // l3lower shouldn't be -1
                //l3index = l3lower;
                l3upper = l3Buffer.size_Renamed_Field - 1;
                for (int k = l2index + 1; k < l2Buffer.size_Renamed_Field; k++)
                {
                    i = l2Buffer.lower32At(k);
                    if (i != -1)
                    {
                        l3upper = i - 1;
                        break;
                    }
                }
            }
            int t1 = l3Buffer.intAt(l3lower);
            int t2 = l3Buffer.intAt(l3upper);
            i = System.Math.Min(l3lower + (int)(((float)(index - t1) / (t2 - t1 + 1)) * (l3upper - l3lower)), l3upper);
            while (i < l3Buffer.size_Renamed_Field - 1 && l3Buffer.intAt(i) < index)
            {
                i++;
            }
            while (l3Buffer.intAt(i) > index && i > 0)
                i--;
            //System.out.println(" i ===> "+i);
            context[3] = l3Buffer.intAt(i);
            l3index = i;
        }


        /// <summary>
        ///    
        /// (New since version 2.9)
        /// Shallow Normalization follows the rules below to normalize a token into
        /// a string
        /// *#xD#xA gets converted to #xA
        /// *For a character reference, append the referenced character to the normalized value.
        /// *For an entity reference, recursively apply step 3 of this algorithm to the replacement text of the entity.
        /// *For a white space character (#x20, #xD, #xA, #x9), append a space character (#x20) to the normalized value.
        /// *For another character, append the character to the normalized value.
        /// @param index
        /// @return
        /// @throws NavException
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>

        public String toNormalizedString2(int index)
        {
            int type = getTokenType(index);
            if (type != TOKEN_CHARACTER_DATA &&
                    type != TOKEN_ATTR_VAL)
                return toRawString(index);
            long l;
            int len;
            len = getTokenLength(index);
            if (len == 0)
                return "";
            int offset = getTokenOffset(index);
            int endOffset = len + offset - 1; // point to the last character
            StringBuilder sb = new StringBuilder(len);

            int ch;

            //boolean d = false;
            while (offset <= endOffset)
            {
                l = getCharResolved(offset);
                ch = (int)l;
                offset += (int)(l >> 32);
                if (isWS(ch) && (l >> 32) <= 2)
                {
                    //d = true;
                    sb.Append(' ');
                }
                else
                    sb.Append((char)ch);
            }
            return sb.ToString();
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected bool matchNormalizedTokenString2(int index, String s)
        {
            int type = getTokenType(index);
            int len =
                (type == TOKEN_STARTING_TAG
                    || type == TOKEN_ATTR_NAME
                    || type == TOKEN_ATTR_NS)
                    ? getTokenLength(index) & 0xffff
                    : getTokenLength(index);

            return compareNormalizedTokenString2(getTokenOffset(index), len, s) == 0;

        }
        /// <summary>
        /// compareNormalizedTokenString2
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="len"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        protected int compareNormalizedTokenString2(int offset, int len,
                String s)
        {
            int i, l, temp;
            long l1, l2;
            //boolean b = false;
            // this.currentOffset = offset;
            int endOffset = offset + len;

            // System.out.print("currentOffset :" + currentOffset);
            l = s.Length;
            // System.out.println(s);
            for (i = 0; i < l && offset < endOffset; )
            {
                l1 = getCharResolved(offset);
                temp = (int)l1;
                l2 = (l1 >> 32);
                if (l2 <= 2 && isWS(temp))
                    temp = ' ';
                int i1 = s[i];
                if (i1 < temp)
                    return 1;
                if (i1 > temp)
                    return -1;
                i++;
                offset += (int)(l1 >> 32);
            }

            if (i == l && offset < endOffset)
                return 1;
            if (i < l && offset == endOffset)
                return -1;
            return 0;
            // return -1;
        }

        /// <summary>
        /// 
        /// Return the byte offset and length of up to i sibling fragments. If 
        /// there is a i+1 sibling element, the cursor element would 
        /// move to it; otherwise, there is no cursor movement. If the cursor isn't 
        /// positioned at an element (due to XPath evaluation), then -1 will be 
        /// returned
        /// @param i number of silbing elements including the cursor element
        /// @return a long encoding byte offset (bit 31 to bit 0), length (bit 62 
        /// to bit 32) of those fragments 
        /// @throws NavException
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public long getSiblingElementFragments(int i)
        {
            if (i <= 0)
                throw new ArgumentException(" # of sibling can be less or equal to 0");
            // get starting char offset
            if (atTerminal == true)
                return -1L;
            // so is the char offset
            int so = getTokenOffset(getCurrentIndex()) - 1;
            // char offset to byte offset conversion
            if (encoding >= FORMAT_UTF_16BE)
                so = so << 1;
            BookMark bm = new BookMark(this);
            bm.recordCursorPosition();
            while (i > 1 && toElement(VTDNav.NEXT_SIBLING))
            {
                i--;
            }
            long l = getElementFragment();
            int len = (int)l + (int)(l >> 32) - so;
            if (i == 1 && toElement(VTDNav.NEXT_SIBLING))
            {
            }
            else
                bm.setCursorPosition();
            return (((long)len) << 32) | so;
        }

        /// <summary>
        /// Return the prefix of a token as a string if the token 
        /// is of the type of starting tag, attribute name, if the 
        /// the prefix doesn't exist, a null string is returned;
        /// otherwise a null string is returned
        ///
        /// </summary>
        /// <param name="i">VTD index of a token</param>
        /// <returns> prefix string</returns>

        public String getPrefixString(int i)
        {
            if (ns == false)
                return null;
            int type = getTokenType(i);
            if (type != TOKEN_ATTR_NAME && type != TOKEN_STARTING_TAG)
                return null;
            int offset = getTokenOffset(i);
            int preLen = getTokenLength(i) >> 16;
            if (preLen != 0)
                return toRawString(offset, preLen);

            return null;
        }
    }
}
